% -*- coding: utf-8 -*-
@import: settings

let programming = '<
  +p{
    既に述べたように，\SATySFi;はいわゆる函数型らしい特徴を兼ね備えた
    組版処理向けのマークアップ言語である．
    むしろ，より正確を期して言い表すならば
    値呼びの函数型言語の上に組版処理用の種々の言語機能が分厚く搭載された
    DSL（domain-specific language, 領域特化言語）だ．
    プログラミング言語としての\SATySFi;の基礎的部分には
    OCamlに大変よく似た体系が採用されており，
    基礎的部分の理解を得るのに
    \cite[`Igarashi-OCaml`];や\cite[`Asai-OCaml`];
    といったOCamlに関する参考書，
    或いは
    \cite[`Igarashi-Program`];や\cite[`TaPL`];（およびその和訳 \cite[`TaPL-ja`];）
    といった計算機言語や型システムに関する基礎理論を扱った理工書で代用することも十分可能なほどである．
    とはいえ，OCamlなどの他言語から回り道せずとも\SATySFi;での最低限の直観を身につければ
    十分\SATySFi;でのプログラミングが可能であり，
    熱心に函数型プログラミングの基礎を習得したい読者ばかりではないであろうから，
    ここでも簡単にプログラミング言語としての\SATySFi;について解説する．
    また，OCamlと\SATySFi;との間には目的意識や美意識の違いに起因した多少の差異があるので，
    これについて（既にOCamlで流暢にプログラミングできる読者に対しても）
    \ref-subsection(`diff-from-ocaml`);で簡単に補足する．
  }
  +subsection{式と値}<
    +p{
      \SATySFi;には対話環境が特に整備されていないので，
      プログラムの計算結果をPDFに出力して確かめることにしよう．
      ひとまず以下のようなコードを見てほしい：

      \d-code(```
        @require: stdjareport

        let-inline \show-int n = embed-string (arabic n)
        let-inline \show-float x = embed-string (show-float x)
        let-inline \show-string s = embed-string s
        in

        document (|
          title = {Programming in \SATySFi;};
          author = {計 算太郎};
        |) '<
          +p{ Answer: \show-int(40 + 2); }
        >
      ```);%

      \codem{let-inline}から始まる，
      未知でありながら前節で見たインラインコマンドを定義する方法によく似た構文が3つ連なっているが，
      実際これはそれぞれ
      \codem{\\show-int}，\codem{\\show-float}，\codem{\\show-string}
      というインラインコマンドの定義である．
      この定義をどう読むのかは後々わかることになるので，
      今の段階ではそれぞれ
      「与えられた
      \meta-or{|整数|浮動小数点数|文字列|}
      を版面に（数値の場合十進法で）出力するコマンド」
      を定義するオマジナイだと思っていただきたい．
      注目されたいのは\codem{\\show-int}を使う部分，すなわち

      \d-code(```
        ​  +p{ Answer: \show-int(40 + 2); }
      ```);%

      である．丸括弧に囲まれた\codem{40 + 2}という怪しげな記述がある．
      とりあえず，この文書を\SATySFi;処理系にかけてみると，
      この段落に相当する部分は

      \d-block(open Sample in '<
        +p{ Answer: \show-int(40 + 2); }
      >);%

      と出力される．そう，${40} と ${2} の和が計算されているのである．
      平たく言えば，こういった “計算をする処理” がプログラムの仕事の根幹であり，
      “計算をする処理” をプログラムとして記述することをプログラミングと呼ぶ．
      \codem{40 + 2}のような記述は
      \dfnje{\index(`シキ`){式}}{expression}
      またはしばしば
      \dfnje{\index(`コウ`){項}}{term}と呼ばれ，
      式を適切な構文にしたがって組み立てることでプログラムが構築される\footnote{
        C言語やPythonなどの
        “手続き的な” 観点に強く基づいている計算機言語に馴染みのある読者は
        「式から文をつくり，文からプログラムを構築するのではないか？」
        と思われるかもしれないが，
        \SATySFi;に文の概念はない．
        というか，式の特殊な場合が “手続き的な” 言語に備わっている文に相当するのである．
        これはOCamlをはじめとする多くのいわゆる函数型言語に共通する性質である．
      }．
    }
    +p{
      \codem{40 + 2}の “計算が進んで” \codem{42}になったように，
      式は一般に “それ以上計算しない式” へと “うつりかわっていく”．
      この “うつりかわり” の過程を
      \dfnje{\index(`ヒョウカ`){評価}}{evaluation}
      またはしばしば
      \dfnje{\index(`カンヤク`){簡約}}{reduction}
      と呼び， “それ以上計算しない式” を
      \dfnje{\index(`コウブンテキアタイ`){構文的値}}{syntactic value}
      或いは単に
      \dfnje{\index(`アタイ`){値}}{value}
      と呼ぶ．
      プログラムの動作とは，式を評価して値を求めることなのである．
    }
    +p{
      もう少し複雑な計算をしてみよう．

      \d-code-and-block(```
        +p{ Answer: \show-int(1 + 2 * 3 - 4); }
      ```)(open Sample in '<
        +p{ Answer: \show-int(1 + 2 * 3 - 4); }
      >);%

      \codem{\*}は乗算のための2項演算子である．
      通常我々が「${1 + 2 \times 3 - 4}」と書いた時には
      ${\paren{1 + \paren{2 \times 3}} - 4} と扱われるのと同様に，
      \SATySFi;言語でも2項演算子の結合には優先順位がある．
      やはり日常的な数式と同様に，括弧で囲うと優先順位を指示できる：

      \d-code-and-block(```
        +p{ Answer: \show-int((1 + 2) * 3 - 4); }
      ```)(open Sample in '<
        +p{ Answer: \show-int((1 + 2) * 3 - 4); }
      >);%

      なお，\SATySFi;での整数は
      64bit環境であれば63bit符号つき整数，
      32bit環境であれば31bit符号つき整数である\footnote{
        この仕様は\SATySFi;の処理系の実装に使われているOCamlの
        \code(`int`);型の仕様に起因する．
      }．
    }
  >
  +subsection?:(`variables`){変数とその束縛}<
    +p{
      ただ単に整数の計算をするだけでは電卓を叩いているのと大して違いはないから，
      もう少し “プログラミングらしいこと” に踏み込もう．
      すなわち，\dfnje{変数}{variable}の使用である．
      変数は，\dfnje{変数名}{variable name}によって識別され，
      何らかの値を\dfnje{束縛する}{bind}ことのできる機構だ．
      変数名として使えるのは，

      \listing{
        * 1文字目はラテン小文字（\codem{a}–\codem{z}）

        * 2文字目以降は大小ラテン文字（\codem{a}–\codem{z}，\codem{A}–\codem{Z}），
          数字（\codem{0}–\codem{9}），
          またはハイフン（\codem{-}）
      }%

      を満たす，長さが1文字以上のコード中の文字列である．
      ただし，これに該当する文字列のうち
      以下に列挙した39種類は\dfnje{予約語}{reserved word}と呼ばれ，
      構文を示すなどの特別な用途で用いられることが定められたトークンなので，
      変数名には使えない\footnote{
        \codem{controls}と\codem{cycle}は今では特に使われないのだが，
        かつてグラフィックスに用いられていたTikZ風の構文の名残として予約語のままになっている．
      }：

      \tokens{
        |and|as
        |before|block-cmd
        |command|constraint|controls|cycle
        |do|direct
        |else|end
        |false|fun
        |if|in|inline-cmd
        |let|let-block|let-inline|let-math|let-mutable|let-rec
        |match|math-cmd|mod|module
        |not
        |of|open
        |sig|struct
        |then|true|type
        |val
        |when|while|with
        |}

      変数名に関して少しだけ注意を喚起しておくと，
      “整数を格納した変数\codem{x}から1引く式” を意図して
      \codem{x-1}と書くと，意図とは異なる結果になる．
      というのも，これは\codem{x-1}全体でひとつの変数名とみなされてしまうためだ\footnote{
        このような記述をすると，多くの場合は型検査器が
        「\codem{x-1}という未定義の変数が使われている」
        というエラーを出すが，
        \codem{x-1}という名前の変数が整数を格納する変数として
        本当に使われている場合はとても厄介で，発見困難なバグの原因になるだろう．
      }．回避策として，
      2項演算子を使うときには\codem{x - 1}のように
      必ず前後に空白文字をひとつずつ入れることを習慣づけるとよいだろう．
      前後に空白文字を入れていないことによりトークンの切り分け方が意図とは異なる結果になることは
      \codem{-}以外にも多くのパターンがあるので，
      2項演算子を式と式の間に中置して使うときには前後に空白文字を入れることを強く推奨する．
    }
    +p{
      さて，肝腎の変数への値の束縛は

      \d-codem{
        let \meta{x} = \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      という形をもつ\dfnje{let式}{let-expression}で行なう\footnote{
        ここにイタリック体で
        \codem{\meta{x}}とか\codem{\metasub(${1}){expr}}などと書いたのは
        “メタ文字” であり，
        実際にコード中に\codem{x}とか\codem{expr1}といった文字列を書いているわけではなく，
        適宜あてはめるべきものに読み替えよ，ということを指す記述である．
        以降もこの “メタ文字” は頻繁に登場するので是非慣れて頂きたい．
      }．
      \codem{\meta{x}}が束縛される変数名であり，
      \codem{\metasub(${1}){expr}}および
      \codem{\metasub(${2}){expr}}は式である．
      このlet式は，\codem{\metasub(${1}){expr}}を評価した結果の値を
      変数\codem{\meta{x}}に束縛し，
      そして\codem{\metasub(${2}){expr}}を評価するのに使う．
      要するに，\codem{\metasub(${2}){expr}}中では
      変数\codem{\meta{x}}が
      \codem{\metasub(${1}){expr}}を評価した結果の値として使えるのである．
      実際に使ってみよう：

      \d-code-and-block(```
        +p{ Answer:
          \show-int(
            let n = (1 + 2) * 3 - 4 in
              n * n * n
          );
        }
      ```)(open Sample in '<
        +p{
          Answer:
          \show-int(
            let n = (1 + 2) * 3 - 4 in
              n * n * n
          );
        }
      >);%

      あまりにも大したことのない例だが，期待どおり計算できていることがわかる．
    }
    +p{
      ここですでにC言語やPythonなどの “手続き的な” 言語に慣れ親しんでいる人は
      特によく注意されたいのだが，束縛は「代入」とは似て非なる概念である．
      \SATySFi;に於ける変数は
      （OCamlなどその他のいわゆる函数型言語の変数にも共通するのだが）
      “値を入れておき，適宜変更できる箱” ではない．
      むしろ，“値に別名をつけたもの” という直観の方が正確である．
    }
  >
  +subsection{基本的なデータ}<
    +p{
      \SATySFi;で扱えるデータは勿論整数だけではない．
      浮動小数点数，文字列，真偽値，さらには
      組版指定のための\dfnje{長さ}{length}の値などが扱える．
      長さについては\ref-subsection(`length`);で，
      真偽値は\ref-subsection(`conditionals`);で
      条件分岐とともに解説するので，
      ここではひとまず浮動小数点数と文字列について紹介する．
    }
    +p{
      まずは小数などの値を扱うためのデータ，
      \dfnje{浮動小数点数}{floating-point number}である．
      \SATySFi;での浮動小数点数の扱いは
      \dfn{IEEE754} \cite[`IEEE754`];に準拠するものとする．
      また，先走って型について述べておくと，
      浮動小数点数は\type(Type.float);型をつけて扱われる．
      浮動小数点数の値をPDFに出力して確認するために，
      最初に掲げたテンプレートの段落の部分を
      以下のように\codem{\\show-float}に変更しよう：

      \d-code(```
          +p{ Answer: \show-float(42.195); }
      ```);%

      整数の\codem{\\show-int}のときと同様に，
      上の\codem{42.195}と書いてあるところを変えて遊んでみる．
      浮動小数点数のリテラルは単純に\codem{42.195}とか\codem{3.14}などと書く．
      現在のところ「\code(`1e-5`);」のような指数表記は用意していない．
      小数部分が\codem{.0}の場合は\codem{5.0}を省略して\codem{5.}といった具合に書けるが，
      整数部分が\codem{0.}の場合は\codem{.5}といった具合には省略できない．
      浮動小数点数も整数と同様に加減乗除などの計算ができるが，
      演算子は\codem{+}や\codem{\*}ではなく，
      かわりに\codem{+.}や\codem{\*.}を使う：

      \d-code-and-block(```
        +p{ Answer: \show-float((1.1 +. 0.7) *. 2.4); }
      ```)(open Sample in '<
        +p{ Answer: \show-float((1.1 +. 0.7) *. 2.4); }
      >);%

      整数値と浮動小数点数との演算は，直接はできない．
      型については後述するが，\codem{1 +. 2.0}のような記述は型エラーとなる．
      評価されて整数値になる式\codem{\meta{expr}}
      を浮動小数点数に関する計算に用いたい場合は
      \codem{float \meta{expr}}で浮動小数点数に変換する：

      \d-code-and-block(```
        +p{ Answer: \show-float((float (1 + 2 * 3 - 4)) *. 2.4); }
      ```)(open Sample in '<
        +p{ Answer: \show-float((float (1 + 2 * 3 - 4)) *. 2.4); }
      >);%

      \codem{float}とそれに伴う式との結合は2項演算子より強いので，
      \codem{float 1 + 2 \* 3 - 4}と書くと
      \codem{(float 1) + 2 \* 3 - 4}と等価な式として解釈されてしまうことに注意．
      反対に，浮動小数点数へと評価される式\codem{\meta{expr}}を
      小数部分を切り捨てて整数値として使いたい場合は
      \codem{(round \meta{expr})}という形で書く：

      \d-code-and-block(```
        +p{ Answer: \show-int((round ((1.1 +. 0.7) *. 2.4)) * 2); }
      ```)(open Sample in '<
        +p{ Answer: \show-int((round ((1.1 +. 0.7) *. 2.4)) * 2); }
      >);%

      ただし，\codem{(round \meta{expr})}は
      \codem{\meta{expr}}の評価結果の浮動小数点数が
      正負無限，NaN，または小数部分を切り捨てた整数が
      \type(Type.int);型に収まらない場合の動作は未定義である．
      なお，ここで用いた\codem{float}および\codem{round}は
      実は\dfnje{函数}{function}と呼ばれるものであり，
      後の\ref-subsection(`functions`);で
      これらについてより一般性の高い説明を与える．
    }
    +p{
      続いては文字列である．文字列の “計算結果” を実際にPDFに出力するため，
      やはり最初に掲げたテンプレートの段落の部分を\codem{\\show-string}に変えて使おう：

      \d-code(```
          +p{ Answer: [\show-string(`this is a string`);] }
      ```);%

      この\codem{\`this is a string\`}の部分を色々変えて遊ぶのである．
      \codem{\\show-string( ${\cdots} )\;}のさらに外側が
      \codem{\[}と\codem{\]}で囲まれているが，
      これは単にインラインテキストの一部として書かれた四角括弧の文字で，
      \codem{\\show-string}によって表示される文字列の
      端がどこなのかを見やすくするためにつけているだけである．
      要するに表示させたい文字列値のいずれか一方の端が空白文字であるとき，
      本当にその端に空白文字が入っているかを確認する目的でつけている．
    }
    +p{
      さて，先走って登場してしまったが，\SATySFi;での文字列リテラルは
      両端をバッククォート（\codem{\`}）で囲って記述する．
      多くのプログラミング言語では文字列内容を二重引用符で囲い，
      キャリッジリターンや二重引用符などいくつかの特殊文字は
      バックスラッシュでエスケープして書くような方式が採られるが，
      \SATySFi;にはそのような文字列リテラルの記法はなく，
      代わりに一切エスケープの要らない
      バッククォートによるリテラルだけが備わっている．
      一切エスケープが要らないといっても，
      「\code(``foo`bar``);」のように
      バッククォートを文字列内容に含めたい場合はどうすればよいのだろう？\quad;
      これはMarkdownを書いた経験があれば想像しやすいが，
      バッククォートが内容に現れる場合は
      両端のバッククォートを2個ずつにするのである．
      これにより文字列内容の終端がどこであるかがわかる．
      試しにテンプレートの段落部分を

      \d-code(```
        +p{ Answer: [\show-string(``foo`bar``);] }
      ```);%

      にしてみると，結果は以下のようになる：

      \d-block(open Sample in '<
        +p{ Answer: [\show-string(``foo`bar``);] }
      >);%

      一般化して言うと，
      文字列内容として ${n} 個隣接したバッククォートを含めたいとき，
      左右で同数の ${\paren{n + 1}} 個以上の
      連続したバッククォートで両端を囲めばよい．
    }
    +p{
      ここで，良い意味で性格の悪い読者は
      コーナーケースに気づいたかもしれない：\quad;
      文字列内容の（少なくとも一方の）
      端にバッククォートがくる場合はどうすればよいのだろう？\quad;
      これは簡単で，文字列内容の端がバッククォートの場合は，
      文字列を括るためのバッククォートの連続と文字列内容の端のバッククォートとの間に
      空白文字を挿入するとよい．
      バッククォートで括られた内容は，
      両末端の空白文字の ${0} 個以上を除去して文字列内容にするのである：

      \d-code-and-block(```
        +p{ Answer: [\show-string(`` `bar``);] }
      ```)(open Sample in '<
        +p{ Answer: [\show-string(`` `bar``);] }
      >);%

      たしかに空白文字が除去され，左端がバッククォートになっていることがわかる．
      さて，読者が次に思うことはもう私にはよくわかっている：\quad;
      文字列内容の（いずれかの）末端を本当に空白文字にしたい場合はどうすればいいのだろう？\quad;
      この疑問にもしっかり答えられるので安心してほしい．
      もし左端の空白文字の ${0} 個以上の連続を無視させたくないのであれば，
      文字列の括る左側のバッククォートを\codem{\`}ではなく\codem{\#\`}にするのである．
      バッククォートが2個以上の場合も同様に\codem{\#\`\`}の要領で\codem{\#}を左につける．
      右端の空白文字の ${0} 個以上の連続を無視させたくない場合も同様に
      文字列を括る右側を\codem{\`}ではなく\codem{\`\#}とする．
      バッククォートが2個以上の場合も同様である：

      \d-code-and-block(```
        +p{ Answer: [\show-string(#`` `bar``);] }
      ```)(open Sample in '<
        +p{ Answer: [\show-string(#`` `bar``);] }
      >);%

      たしかに空白文字が残っている．これでようやく安心して文字列リテラルが使える．
    }
    +p{
      文字列リテラルが書けるようになったところで，文字列を構築する方法を伝授しよう．
      文字列の結合は2項演算子\codem{^}でできるほか，
      整数値に評価される式\codem{\meta{expr}}に対し，
      \codem{(arabic \meta{expr})}で整数値を十進法文字列にすることができる：

      \d-code-and-block(```
        +p{ Answer: [\show-string(
          `The result is `# ^ (arabic ((1 + 2) * 3 - 4)) ^ `!`
        );] }
      ```)(open Sample in '<
        +p{ Answer: [\show-string(
          `The result is `# ^ (arabic ((1 + 2) * 3 - 4)) ^ `!`
        );] }
      >);%

      ここで使った\codem{arabic}はやはり函数であり，これに関しては
      \ref-subsection(`functions`);でしっかりと扱う．
    }
    +p{
      なお，インラインテキスト\codem{\{ ${\cdots} \}}と
      文字列は異なる概念であることに注意されたい．
      前者はコマンドなどを内容に含んでいるが，
      後者は純粋にUnicodeコードポイント列である．
      ただし，文字列を
      （等価なテキストで構成された，コマンドを含まない）インラインテキストへと変換することは
      \codem{embed-string}という函数で行える．
      これについても\ref-subsection(`functions`);で扱う．
    }
  >
  +subsection{型システムの基礎}<
    +p{
      ところで，“文字列を整数値に足そうとする” とどうなるだろうか？\quad;
      結論から言うと，そのような計算は意味をなさず，
      しかも型検査器に弾かれて “計算を試みることさえさせてもらえない”．
      整数の計算に使った\codem{\\show-int}を含む最初のテンプレートで，
      試しに以下のように記述して処理してみよう：

      \d-code(```
        +p{ Answer: [\show-int(
          42 + `added string`
        );] }
      ```);%

      次のようなエラーが出るはずである：

      \console(```
        ! [Type Error] at "test.saty", line 12, characters 9-23:
            this expression has type
              string,
            but is expected of type
              int.
      ```);%

      ファイル名\code(`test.saty`);や行数などは実際にどう記述したかで変わるのだが，
      どうであれ実際に\codem{\`added string\`}が書かれている位置を指しているはずだ．
      上記のエラーは\SATySFi;の型検査器が出した\dfnje{型エラー}{type error}であり，
      その意味するところは（ほぼ直訳だが）
      「\codem{\`added string\`}という式は\type(Type.string);型の式だが，
      ここには\type(Type.int);型の式が書かれることが期待されている」だ．
      ここでようやく\SATySFi;の特徴たる\dfnje{型}{type}の登場となる\footnote{
        といっても，プログラミング言語のもつ特徴としては型はごく一般的な概念である．
        型システムを有していることではなく，
        型システムを組版処理を行なう処理系に持ち込んだことが
        \SATySFi;の顕著な特徴なのである．
      }．
      一旦上のような具体的な型エラーを離れ，型についての一般論の時間にしよう．
      型とは，非常に大雑把に言えば “値の種類による分類”，さらには
      “評価した結果どんな種類の値になることが事前にわかっているかに基づく式の分類”
      である．ここで “事前に” と言っているところが非常に重要だ．
      要するに，“計算を実際に行なわなくともどんな種類の値が結果として出てくるのかが
      式の字面%\footnote{より正確には抽象構文木である．}
      だけからわかる”
      ような仕組みが型によって確立されているということであり，
      この仕組みが\dfnje{型システム}{type system}と呼ばれるものだ．
      型システムを反映して与えられたプログラムが整合しているかどうかを判定する機構が
      型検査器であり，この “整合しているかの検査” は
      プログラムをなす各部分の式に型がつくかどうかを判定することで行なわれる．
    }
    +p{
      式に型をつけることの直観は単純である．
      まず，整数値の型として（上の型エラーにも出てきたように）
      \type(Type.int);型が用意されている．
      最初から値であるような\codem{1}とか\codem{2}とか\codem{500000000}といった
      整数リテラルの式は単純にそのまま\type(Type.int);型がつけられる．
      重要なのは，まだ値でない，評価すると “何かしら計算が進む” 式の型つけだ．
      例えば，加算の式\codem{\metasub(${1}){expr} + \metasub(${2}){expr}}は
      どのように型で扱うかというと，
      「\codem{\metasub(${1}){expr} + \metasub(${2}){expr}}に何らかの型がつくなら
      それは\type(Type.int);型であり，そのためには
      \codem{\metasub(${1}){expr}}と
      \codem{\metasub(${2}){expr}}にそれぞれ\type(Type.int);型がつかねばならない」
      という規則が設けられているのである．
      これが型システムという仕組みの大枠だ．
      本当はもう少し一般性の高い仕組みなのだが，それは次節での函数の型つけの説明に譲る．
    }
    +p{
      さて，上で出た型エラーの話に戻る．
      このエラーの要因は，要するに
      \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}という形の式に型をつけるには
      上記の説明どおり\codem{\metasub(${1}){expr}}と
      \codem{\metasub(${2}){expr}}のそれぞれに
      \type(Type.int);型がつくことが要請されるのだが，
      ここでは\codem{\metasub(${2}){expr}}が\codem{\`added string\`}という
      文字列リテラルであり，
      これは（\type(Type.string);型はつくが）
      \type(Type.int);型がつかないと定められている．
      したがって元の加算の式全体には型がつかないことになり，型検査で弾かれるのである．
    }
  >
  +subsection?:(`length`){長さ}<
    +p{
      型システムの基礎を把握してもらったところで，
      組版処理上基礎的なデータのひとつである\dfnje{長さ}{length}と
      その型である\type(Type.length);型を紹介しよう．
      これはおそらく汎用のプログラミング言語には
      それ以上分解できない機能として搭載されているのをまず見ない
      データだろう．
      長さの値は振舞いの上ではほぼ浮動小数点数のようなものではある\footnote{
        現状，長さに関する演算がどのように振舞うかは厳密には規定しない．
        厳密に規定しなければどのように行分割されるかが “処理系依存” になってしまうので
        将来的には規定した方が望ましいのであろうが，
        今のところ公開されている\SATySFi;の処理系は
        著者が実装した1つ（およびそれを他者がforkし長さの扱いに関係しない箇所を改変したもの）
        しかないと思われるのでひとまず気にしなくてよい．
        なお，現在の処理系の実装では（後述する）DTPポイント単位の
        浮動小数点数で内部的に表現されている．
      }が，
      “長さ同士を乗算したものを長さとして使う” といった
      “意味をなさない計算” が安易にはできないように，
      つまりそういった計算をしようとする記述が型検査を通らないように，
      浮動小数点数とは型の上で区別されている．
      長さの定数リテラルは，\codem{2.5cm}とか\codem{-1inch}といった，
      次に該当する構文で書く：

      \d-codem{
        \meta-or{|-||}\meta-or{|〈非負で数値の浮動小数点数〉|〈非負整数〉|}〈単位〉
      }%

      ただし，\codem{〈単位〉}の部分は変数名と同一の規則の文字列である．
      これ全体が長さの定数リテラルをなす1トークンであり，
      負の符号と数値部分の間や数値部分と単位の間に空白文字を入れたりしてはいけない．
      具体的な単位については，あらかじめ定義された以下の
      （“状況” に依存しない，絶対的な）単位のみが使える：

      \listing{
        * \codem{mm}：\quad;
          ミリメートル

        * \codem{cm}：\quad;
          センチメートル

        * \codem{inch}：\quad;
          \dfnje{国際インチ}{international inch}（${1\math-unit!{inch}}を
          厳密に${2.54\math-unit!{cm}}と定めた単位）

        * \codem{pt}：\quad;
          \dfnje{DTPポイント}{DTP point}（${1\math-unit!{pt}}を
          厳密に${\paren{1/72}\math-unit!{inch}}と定めた単位）
      }%

      emやexなどといった，“現在の文字サイズ” に依存する
      相対的な長さの単位は使えないことに注意されたい．
      勿論実質的にem単位で長さを指定する方法は存在し，
      それについては後々わかることになる\footnote{
        大幅に先走って述べておくと，そのような処理は
        \codem{get-font-size}というプリミティヴを用いて実現する．
      }．
      さらに引っかかりやすいポイントは，ポイントという単位の定義だ．
      “point” と呼ばれる単位には歴史的に様々な定義が与えられてきた．
      代表的なものを掲げる：

      \listing{
        * \dfnje{Didotポイント}{Didot’s point}（1783年）：\quad;
          pied du Roi（royal foot，王のフィート）に基づくフランスのインチの厳密に${\paren{1/72}}倍．

        * アメリカンポイント（1886年）：\quad;
          インチの厳密に${0.013837}倍．

        * JIS Z 8305に基づくもの（1962年）：\quad;
          厳密に${0.3514\math-unit!{mm}}．

        * \TeX;ポイント\code(`pt`);（1982年）：\quad;
          国際インチの厳密に${\paren{1/72.27}}倍．

        * \TeX;でのDidotポイント\code(`dd`);（1964年）：\quad;
          \TeX;ポイントの厳密に${\paren{1157/1238}}倍．

        * DTPポイント（1984年）：\quad;
          国際インチの厳密に${\paren{1/72}}倍．
          \dfn{PostScript} \cite[`PostScript`];
          の仕様で導入され，\dfnje{PostScriptポイント}{PostScript point}とも呼ばれる．
          CSSで扱われる\code(`pt`);，および
          \TeX;の\dfnje{ビッグポイント}{big point} \code(`bp`);も，
          これに等しい\footnote{
            ただし，\TeX;での長さの扱いは
            \dfnje{スケールドポイント}{scaled point} \code(`sp`);
            という\TeX;ポイントの厳密に ${\paren{1/65536}}倍の長さの整数倍として表現され，
            ビッグポイントも\TeX;ポイントの
            厳密に ${\paren{65781/65536}}倍として扱われているので，
            定義と実装で差がある．
            といっても\code(`sp`);は ${10^{-6}\math-unit!{mm}}のオーダーなので，
            視覚表現上はこの単位に対する丸め誤差を気にする必要がない．
          }．


      }%

      CSS，PostScript，PDF（および，\code(`bp`);という単位だが，\TeX;）
      などに広くまたがって互換性に優れた
      デファクトスタンダードとして確立されていることを鑑み，
      \SATySFi;は\codem{pt}の定義としてDTPポイントを採用した．
    }
    +p{
      長さに関する基礎的な演算を行なう式は次のとおりである：

      \listing{
        * \codem{\metasub(${1}){l} +' \metasub(${2}){l}}：\quad;
          長さ同士の加算．

        * \codem{\metasub(${1}){l} -' \metasub(${2}){l}}：\quad;
          長さ同士の減算．

        * \codem{\meta{l} \*' \meta{r}}：\quad;
          長さ\codem{\meta{l}}と浮動小数点数\codem{\meta{r}}を受け取り，
          \codem{\meta{l}}を\codem{\meta{r}}倍した長さを返す．

        * \codem{\metasub(${1}){l} /' \metasub(${2}){l}}：\quad;
          長さ\codem{\metasub(${1}){l}}が
          長さ\codem{\metasub(${2}){l}}の
          “何倍の長さであるか” の浮動小数点数を返す．
      }%
    }
  >
  +subsection?:(`functions`){函数定義}<
    +p{
      大抵のプログラミング言語には，頻出する計算手順に名前をつけ，
      その計算手順を1箇所にまとめて記述する方法が備わっている．
      多くの言語と同様に，\SATySFi;では\dfnje{函数}{function}がその役割を担う\footnote{
        函数のほかには，\dfn{Fortran90}などの言語に見られるように
        \dfnje{サブルーティン}{subroutine}と呼ばれる機構がこの役割を担っている言語もある．
      }．
      函数は，何らかの値を受け取り，それを加工して新たな値をつくる処理である．
      例として，円単位の金額を整数で受け取り，
      それをドル単位に換算する函数\codem{to-dollar}を定義してみよう．
      レートはひとまず9月24日19時23分(UTC)に基づいて${1}ドルを${112.73}円とする．
      これは以下のようにして定義できる：

      \d-code(```
        let to-dollar m-yen =
          let rate = 112.73 in
            (float m-yen) /. rate
        in
        （続きの式）
      ```);%

      函数の定義もlet式を用いて行なうのである．
      ここで登場する\codem{m-yen}は\dfn{仮引数}
      または単に\dfn{引数}と呼ばれるもので，
      函数\codem{to-dollar}の受け取る値が格納される変数である．
      ここで例示した\codem{to-dollar}はひとつだけ引数をとる函数だが，
      一般には任意に正整数個とれる．
      函数定義は，次のような構文によって為される：

      \d-codem{
        let \meta{f} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} =
          \metasub(${1}){expr}
        in
          \metasub(${2}){expr}
      }%

      \codem{\meta{f}}が定義したい函数に与える名前であり，
      各\codem{\metasub(${i}){x}}は第 ${i} 引数である．
    }
    +p{
      さて，上で定義した函数\codem{to-dollar}を実際に使ってみよう．
      函数の定義は，パッケージの読み込みの記述から\codem{document}までの間の部分で行なえる．
      すなわち，以下のようになる：

      \d-code(```
        @require: stdjareport

        let-inline \show-int n = embed-string (arabic n)
        let-inline \show-float x = embed-string (show-float x)
        let-inline \show-string s = embed-string s
        in

        let to-dollar m-yen =
          let rate = 112.73 in
            (float m-yen) /. rate
        in

        document (|
          （以降略）
      ```);%

      それでは実際に\codem{to-dollar}を使って円単位の金額をドル単位に換算してみよう．
      函数\codem{\meta{f}}に式\codem{\meta{expr}}の計算結果を渡したいときは
      \codem{\meta{f} \meta{expr}}と書く．
      これを函数\codem{\meta{f}}の式\codem{\meta{expr}}への\dfnje{適用}{application}
      とか式\codem{\meta{expr}}による函数\codem{\meta{f}}の\dfnje{呼び出し}{call}
      と呼ぶ．また，ここで評価結果が\codem{\meta{f}}に渡される式\codem{\meta{expr}}のことを
      \codem{\meta{f}}の\dfn{実引数}と呼ぶ．
      やや厄介なことに，仮引数だけでなくこの実引数も単に\dfn{引数}と呼ばれることが多い．
      しかし「引数」が仮引数の意であるか実引数の意であるかは
      ほとんどの場合使用されている文脈から判断できるので，
      特に違いを強調する必要のない場合は両者ともに引数と書くことにする．
    }
    +p{
      函数\codem{\meta{f}}の式\codem{\meta{expr}}への適用は，次のような流れで評価される：

      \listing{
        * 実引数\codem{\meta{expr}}が評価されて値\codem{\meta{value}}になる．

        * 函数\codem{\meta{f}}の定義
          \codem{let \meta{f} \meta{x} = \meta{e} in ${\cdots}}
          が “思い返される”．

        * 仮引数\codem{\meta{x}}が\codem{\meta{value}}に束縛された下で
          “定義の本体” である式\meta{e}が評価され，その結果が適用の式全体の評価結果となる．
      }%

      不正確ながら大雑把に言ってしまえば，
      函数定義中の仮引数が実引数で置き換えられたものを計算するのが函数適用である．
      さて，実際に\codem{to-dollar}を適用したのが以下だ：

      \d-code-and-block(```
        +p{ Answer: \show-float(to-dollar 10000); }
      ```)(open Sample in '<
        +p{ Answer: \show-float(to-dollar 10000); }
      >);%

      やはり大雑把に言えば，\codem{to-dollar}の “定義本体” の中の\codem{m-yen}がすべて
      \codem{10000}に置き換わったものの計算結果が出ているわけである．
      というわけで10000円は大体88.7ドルくらいであることが計算できた．
    }
    +p{
      函数それ自体にも，整数などと同様に型がつけられる．
      \type(Type.tymtausub ${1});型の引数をとって
      \type(Type.tymtausub ${2});型の値を返す函数には
      \type(Type.(tymtausub ${1} --> tymtausub ${2}));
      という型がつくと定められている．
      例えば，上で定義した\codem{to-dollar}は
      \type(Type.(int --> float));型をもつ．
      このことを以降

      \val({to-dollar})(Type.(int --> float));%

      とコロン（${:}）を挟んで式とそれにつく型を並べることで表記する．
    }
    +p{
      さて，引数が1個の函数はよいとして，複数の引数をとる函数も
      同様の例を通じて説明する．
      先ほどの\codem{to-dollar}は交換のレートが決め打ちされていた．
      今度はレートも引数にして，その都度変えられるようにしてみたい．
      その定義が以下である：

      \d-code(```
        let to-dollar-2 rate m-yen =
          (float m-yen) /. rate
      ```);%

      レート\codem{rate}が第1引数に，日本円の額面\codem{m-yen}が第2引数になるように改めたのである．
      さて，9月26日16時44分 (UTC) のレートは${1}ドル${112.95}円であった．
      このレートであらためて計算してみよう．
      引数が ${n} 個あるとき，函数適用は
      \codem{\meta{f} \metasub(${1}){expr} ${\cdots} \metasub(${n}){expr}}
      という形で書く：

      \d-code-and-block(```
        +p{ Answer: \show-float(to-dollar-2 112.95 10000); }
      ```)(open Sample in '<
        +p{ Answer: \show-float(to-dollar-2 112.95 10000); }
      >);%
    }
    +p{
      ところで，引数が複数個ある函数はどのような型がつくのだろう？\quad;
      結論から言うと，引数を ${n} 個とり，各第 ${i} 引数の型が\type(Type.tymtausub ${i});，
      返り値の型が\type(Type.tymtau);であるような函数には

      \quote{
        \type(Type.(tymtausub ${1} --> (of-math ${\cdots} --> (tymtausub ${n} --> tymtau))));
      }%

      という型がつく．例えば上で定義した\codem{to-dollar-2}は
      \type(Type.(float --> (int --> float)));という型をもつという具合である．
      この矢印が連なった型は実は新たな記法などではなく，
      括弧を省略せずに書くと

      \quote{
        \type(Type.(tymtausub ${1} --> (synt-paren (tymtausub ${2} -->
          (synt-paren (of-math ${\cdots} --> (synt-paren (tymtausub ${n} --> tymtau))))))));
      }%

      という型である．つまり
      “矢印で構築される函数の型\type(Type.(tymtau --> tymtaup));の
      \type(Type.tymtaup);の側がさらに函数の型になっている” という構造が
      繰り返されてできているのが上記の型なのである．
      だが，どうして ${n} 引数函数の型がこのように表されるのだろうか？\quad;
      これは次のような考察に基づくものだ：

      \quote{
        \type(Type.tymtausub ${1});型の第1引数と
        \type(Type.tymtausub ${2});型の第2引数を受け取って
        \type(Type.tymtau);型の値を返す函数は，
        \type(Type.tymtausub ${1});型の引数を受け取って
        「\type(Type.tymtausub ${2});型の引数を受け取って
        \type(Type.tymtau);型の値を返す函数」を返す函数ともみなせる．
      }%

      これはいわゆる函数型言語が基盤とする理論の中でも初歩となる重要な点で，
      この考察に基づく “変換” を\dfnje{カリー化}{currying}と呼ぶ．
      このことは次に説明する\dfnje{部分適用}{partial application}を
      念頭に置くととても自然に理解できる．
      部分適用とは，簡単に言えば “一部の引数しか渡さないこと” である．
      先ほど定義した\codem{to-dollar-2}に，
      第1引数であるレートの値のみ渡して部分適用することにより
      別の函数を定義してみよう：

      \d-code(```
        let to-dollar-par = to-dollar-2 112.73
      ```);%

      この\codem{to-dollar-par}は
      「日本円での額面を受け取り，それをレート${112.73}円/ドルに基づいてドルの額面にして返す函数」
      であり，型として\type(Type.(int --> float));をもつ．
      \type(Type.(int --> string));型の函数に引数として\type(Type.int);型を渡すと
      返り値の型が\type(Type.string);型であるのと全く同様に，
      \type(Type.(float --> (synt-paren (int --> float))));型の\codem{to-dollar-2}に
      \type(Type.float);型の式を渡す記述だから\type(Type.(int --> float));型なのである．
      こうして定義した\codem{to-dollar-par}は，
      最初に掲げた\codem{to-dollar}と等価な振舞いをする函数になっている．

      また，部分適用と対応するように，実は複数の実引数の適用

      \d-codem{
        \meta{f} \metasub(${1}){expr} ${\cdots} \metasub(${n}){expr}
      }%

      も，括弧を略さずに書くと

      \d-codem{
        (((\meta{f} \metasub(${1}){expr}) \metasub(${2}){expr}) ${\cdots} ) \metasub(${n}){expr}
      }%

      である．これは函数適用\codem{\metasub(${1}){expr} \metasub(${2}){expr}}に於いて
      \codem{\metasub(${1}){expr}}が\type(Type.(tymtau --> tymtaup));型を，
      \codem{\metasub(${2}){expr}}が\type(Type.(tymtau));型をもつことが
      検査されることから考えると自然だろう．
      平均的な型システムの入門的解説に比べるとかなり駆け足になってしまったが，
      以上が函数につけられる型と部分適用の仕組みだ．
    }
    +p{
      ところで，これもいわゆる函数型言語が基盤とする理論としては重要な点なのだが，
      函数はいちいちlet式で名前をつけて扱う必要はない．
      例えば，上でlet式で定義した\codem{to-dollar-2}は
      \codem{to-dollar-2}と名前をつけずとも以下のように\dfn{無名函数}\footnote{
        理論的には\dfnje{ラムダ抽象}{${\lambda}-abstraction}と呼ばれるものである．
      }で書ける：

      \d-code(```
        (fun rate m-yen -> (float m-yen) /. rate)
      ```);%

      勿論この例ではわざわざこう書く必要はないのだが，
      後述する高階函数では役立つことが多い．
      「役立つことが多い」などと，
      あたかも無名函数が “後から言語機能に足された瑣末なもの” であることを
      示唆するかのような言い方になってしまったが，
      実はこの無名函数はlet式による函数の定義よりも言語機能として基盤にあるものだ．
      函数を定義するlet式

      \d-codem{
        let \meta{f} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} =
          \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      は，実は以下の糖衣構文にすぎない：

      \d-codem{
        let \meta{f} = (fun \metasub(${1}){x} ${\cdots} \metasub(${n}){x} -\>
          \metasub(${1}){expr}) in \metasub(${2}){expr}
      }%

      つまり，前者は処理系で内部的に（構文解析が終わり，型検査が始まる前に）
      後者に変換されているのである．
      後者のlet式は\ref-subsection(`variables`);で最初に紹介したlet式そのものである．
      すなわち，函数定義は単に変数束縛の一種だったのである．
      “函数” と “変数” の垣根がないことは，
      \SATySFi;が拠り所とするML系言語の重要な特徴である\footnote{
        いわゆる函数型言語にあっても，“函数” と “変数” とが
        別個の概念としてある言語は存在する．
        \dfn{Common Lisp}などが有名である．
      }．
      ちなみに，もっといえば

      \codem{
        (fun \metasub(${1}){x} ${\cdots} \metasub(${n}){x} -\>
          \meta{expr})
      }%

      も

      \codem{
        (fun \metasub(${1}){x} -\> (fun \metasub(${2}){x} -\> ${\cdots} (fun \metasub(${n}){x} -\>
          \meta{expr}) ${\cdots}))
      }%

      の糖衣構文である．これは先ほど部分適用で説明したこととも対応しており，
      要するに ${n} 引数をとる函数とは “1引数函数が ${n} 重入れ子になったもの”
      である，ということだ．
    }
    +p{
      すでに述べたが，浮動小数点数や文字列などのデータの説明で登場した
      \codem{arabic}，\codem{float}，\codem{round}は，
      それぞれ以下のような型をもつプリミティヴの函数である：

      \listing{
        * \codem{arabic} : \type(Type.(int --> string));
        * \codem{float} : \type(Type.(int --> float));
        * \codem{round} : \type(Type.(float --> int));
      }%

      函数につく型については上記の説明ですでによく把握されているだろうから，
      それぞれにこのような型がつくことはもはや当然のように感じられるだろう．
    }
    +p{
      さらには，2項演算子も実は函数である．
      \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}は
      実は\codem{(+) \metasub(${1}){expr} \metasub(${2}){expr}}
      という函数適用の糖衣構文であり，2項演算子\codem{+}の正体は
      \codem{(+)}という3トークンからなる特殊な名前をもつ変数なのである．
      \codem{(+)}は\type(Type.(int --> (int --> int)));という型をもち，
      それゆえに\type(Type.(int));型のつかない引数を与えると
      型検査器にエラーを返されていたのである．
      さらに，2項演算子は（通常の変数名の函数と同様に）自分で定義することもできる．
      使える名前は，
      \codem{\meta-or{|+|-|\*|/|^|\&|\||!|:|=|\<|\>|~|'|.|?|}}を
      \codem{\meta{opsymb}}と表すとして

      \listing{
        * \codem{\meta-or{|\*|/|}\meta-star{\meta{opsymb}}}
        * \codem{\meta-or{|+|-|}\meta-star{\meta{opsymb}}}
        * \codem{^\meta-star{\meta{opsymb}}}
        * \codem{\meta-or{|=|\>|\<|}\meta-star{\meta{opsymb}}}
        * \codem{\&\meta-plus{\meta{opsymb}}}
        * \codem{\|\meta-plus{\meta{opsymb}}}
      }%

      にマッチするもののうち，以下に該当しないものである\footnote{
        \codem{--}は実質的に使われなくなっているが，
        歴史的経緯から特殊なトークンとして残存している．
      }：

      \tokens{|=|--|-\>|}%

      結合の強さは先に挙げたものほど強いとする．
      いずれも左結合である．
    }
  >
  +subsection?:(`conditionals`){真偽値と条件分岐}<
    +p{
      真偽値は “正しいか正しくないか” を表すデータであり，\type(Type.bool);型をつけて扱う．
      \type(Type.bool);型のつく式はおおよそ “命題” に対応し，
      \type(Type.bool);型の値としては
      真に対応する ${\term!(Term.truev)} と
      偽に対応する ${\term!(Term.falsev)} との2種類のみがある．
    }
    +p{
      真偽値に関連する言語機能として，
      “何が成り立っているかによってその先の処理を変える” 記述，
      すなわち\dfnje{条件分岐}{conditional branching}がある．
      例として整数の絶対値函数\codem{abs}を定義してみよう：

      \d-code(```
        let abs n =
          if n < 0 then - n else n
      ```);%

      ここで使われる
      \codem{if \metasub(${0}){expr}
        then \metasub(${1}){expr} else \metasub(${2}){expr}}
      が条件分岐に使われる\dfnje{if式}{if-expression}であり，
      直観的には
      「\metasub(${0}){expr}が成り立つならば\metasub(${1}){expr}を，
      そうでないならば\metasub(${2}){expr}を評価する」
      を意味する．
      型つけの規則としては，
      \codem{\metasub(${0}){expr}}は\type(Type.bool);型であることと，
      \codem{\metasub(${1}){expr}}と\codem{\metasub(${2}){expr}}とに
      同一の型がつくことが要請される．
      ここでの例は，整数を比較する2項演算子\codem{\<}を用いて
      与えられた引数が\codem{0}未満であるかどうかを判定しており，
      負の値であった場合は符号を反転し，非負の値であった場合はそのまま返す，
      ということを記述している．
      ちなみに，条件分岐の話とは関係ないが，
      注意深い人は\codem{- n}という部分が新しい構文であることに気づいただろう．
      これは\codem{-}という名前の2項演算子のみに与えられた特殊な機能で，
      大雑把に言えば “左側の引数を省略した場合は\codem{0}として扱う” というものだ．
      要するに符号の反転を自然に書くための機能である\footnote{
        浮動小数点数用の\codem{-.}や長さ用の\codem{-'}には，
        この機能は現状備わっていない．将来的に追加したいとは考えている．
      }．ともあれ，この\codem{abs}の動作を確認してみる：

      \d-code-and-block(```
        +p{ Answer: \show-int(abs (abs (1 - 2) * 3 - 4)); }
        +p{ Answer: \show-int(abs (abs (1 + 2) * 3 - 4)); }
      ```)(open Sample in '<
        +p{ Answer: \show-int(abs (abs (1 - 2) * 3 - 4)); }
        +p{ Answer: \show-int(abs (abs (1 + 2) * 3 - 4)); }
      >);%
    }
    +p{
      論理演算として
      選言\codem{\|\|} : \type(Type.(bool --> (bool --> bool)));，
      連言\codem{\&\&} : \type(Type.(bool --> (bool --> bool)));，
      否定\codem{not} : \type(Type.(bool --> bool));
      などが用意されており，これを用いてより複雑な条件の指定ができる．
      最初から使える種々の演算は\ref-subsection(`arithmetic`);に掲載したので参照されたい．
    }
  >
  +subsection{型システムと型推論の恩恵}<
    +p{
      式に型がつくことで，その式を評価しても
      “値の種類に由来するエラー” は起きないということが保証される．
      というか，型システムはこういったエラーを
      プログラムを評価せず事前に検出して弾くためにあるわけである．
      型なしの言語（いわゆる動的型つき言語\footnote{
        「動的型」と言ったときの「型」は，
        ここで説明した型の概念とは似て非なるもので，
        “実行時にデータの種類を示すものとして値についているタグ”
        であることに注意されたい．
        繰り返しになるが，この本で使用しているのと同様の意で
        「型」と言った時は “式に対して事前にわかる分類”
        である．動的型との混同を避けて
        俗に静的型と呼ばれることもある．
        歴史的には動的型を指して「型」という語を使う方が
        ずっと後発の用法である．
      }）に馴染みの深い読者なら，もしかすると
      「静的型を入れず，
      整数値に文字列を足す処理が書かれたら前者を十進文字列にして
      文字列結合にするように\codem{+}を定義すればよいのでは？\quad;
      逐一\codem{arabic}で整数値を文字列値へ変換する処理を
      明示的に書く必要もないし楽になるだろう」
      などと考えるかもしれない．
      だが，
      \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}
      の形の式の計算結果が整数値にも文字列値にもなりうるというのは
      そんなに “うれしいこと” ではない．
      式に型をつけないという言語設定を仮定した下で，次のような函数を考えよう：

      \d-code(```
        let f x =
          let y = 42 + x in
            y / 2
      ```);%

      型なしの言語だったりして，
      整数値と文字列値の加算が許容されるとしよう．
      このとき，上記の\codem{f}に渡される\codem{x}の “値の種類” によっては，
      除算\codem{y / 2}に於いて
      \codem{y}が文字列値など整数値でない場合も扱わねばならないことになる．
      除算の定義をどうするか，ここで2通りの選択肢がある：

      \listing{
        * 整数値以外が左側にきた場合は実行時エラーとする．

        * 整数値以外が左側にきた場合，結果を必ず\codem{0}にしたり，
          何も処理せずその値を返したりと，
          とにかく何かしらそれらしい値を返して実行時エラーにはしない．
      }%

      前者を採用した場合，
      これはまさに型システムを入れることで除外したかった
      “値の種類による実行時の破綻” だ．
      「この実行時エラーを許容してもよいから静的に型をつけたくない」
      という主義の人もいるかもしれないが，
      ほとんどの場合その決断は割りに合わないと言ってよい．
      型なしの言語で数千行規模のプログラムを書くと
      （静的型つきの言語で書いた場合に比べて）
      急速に保守が困難になることは想像に難くないし，
      経験的にもそうであることが多いはずだ．
      もし貴方が数千行規模のプログラムを型なしの言語で書いて保守しており，
      かつ特に苦労していると思っていないなら，
      それは単に型なし言語のデバッグの労苦に飼い慣らされていて，
      静的型つきの言語の世界観から見れば大部分は要らぬ苦労をしているだけ，
      という可能性は非常に高い．

      一方で後者を採用した場合，
      計算が失敗することはないが，
      些細な間違いに対してもデバッグが非常に困難になる．
      どこで意図しない計算が生じているか
      事細かに追わないとわからないからだ．
      特に組版処理のように “扱う値の種類” が多い場合，
      “種類の違い” による意図しない計算は生じるリスクが大きく，
      致命的に修正困難な状況に陥りやすいだろう．
      要するに，“値の種類によらず計算に失敗しないようにする” ことも
      “そんなに嬉しくない” のである．
    }
    +p{
      とにかく，人間はプログラムを書く際にはひたすら間違い続ける．
      しかもその間違いは，かなりしょうもないものであることが経験的に多そうだ．
      型検査器は人間の犯すミスのうち或る種の不整合を丁寧にも事細かに指摘してくれる．
      決してお節介なお婆さんではない．
      「“式の種類” に関して不整合のあるプログラムを書いたときに
      型検査器がその不整合を教えてくれ，
      それに基づいて該当箇所をスムーズに修正できる」という利点は，
      「“異なる種類” への値の変換を\codem{arabic}のような形で明示的に書かなければならない」
      という多少の厄介さを補ってあまりがありすぎるほどの恩恵である．
      また，これは非常に誤解が多いのだが，
      プログラムに静的に型をつけるのに
      \dfnje{型註釈}{type annotation}，
      つまり各変数にどのような型をつけるかを明示した註釈が必要なわけでは
      必ずしもない\footnote{
        「静的型つきの言語は逐一変数につく型を書かないといけないから面倒」
        という誤解は，おそらくC言語のような型註釈が省略できない
        （或る意味特殊な）静的型つき言語の存在によるところが大きそうだ．
        一般に静的型つき言語で変数の型註釈が省略できないわけでは決してない．
      }．
      適切に型システムを設計すれば，与えられたプログラムが “整合している” 限り，
      全部または一部の変数にどのような型がつくか，型推論で求められるのである．
      特に\SATySFi;を含めOCaml，F\#，Standard ML，Haskellなど多くの言語の型システムが
      その理論的基盤としている
      \dfn{Damas–Hindley–Milner多相}\footnote{
        \dfn{Hindley–Milner多相}，\dfn{Damas–Milner多相}，
        \dfn{let多相}，\dfn{冠頭多相}などとも呼ばれる．
      } \cite[`Hindley1969`; `Milner1978`];は，
      型推論が\dfnje{完全性}{completeness}をもつ，
      すなわち変数に一切型註釈のない式に対しても
      必ずその式につく “最も一般的な型” である\dfnje{主要型}{principal type}
      が存在してかつそれを求めるアルゴリズムが知られているという性質があり，
      それゆえに特に\SATySFi;やOCamlでは
      よほど複雑な機能を使わない限り基本的に型註釈を書かなくてよいという状況が達成されている．
      つまり型註釈が現実的にプログラマの手を煩わせることはほとんどない．
      むしろ型註釈が省略できすぎるので，
      （2週間後の自分が見てプログラムを読めなくなることのないように）
      型検査器からすればなくてもよい型註釈を可読性のために入れるくらいである\footnote{
        Haskellはlet多相を基盤としていながらも
        \dfnje{型クラス}{typeclass}がある影響で
        型註釈が省略できない場合が顕著にみられ，
        それゆえかトップレヴェルで定義する函数には必ず型註釈を入れる慣習がある．
        たまに「型が函数定義の本体であって，実装はオマケにすぎない」
        という主張をする人がいるが，これは
        （\dfnje{篩型}{refinement type} \cite[
          `FreemanPfenning1991PLDI`; `KnowlesFlanagan2007ESOP`;
          `RondonKawaguchiJhala2008PLDI`;
        ];のような，
        通常の型よりもずっと強力な型を扱う型システムでもない限り）
        過言気味だ．
        型から実装が決まるわけでは決してないためだ．
        例えば返り値の型が\type(Type.bool);の函数なら，
        “最後に\codem{not}をかませるような実装に変更する” だけで
        元と同一の型がつくが振舞いの全く異なる函数の実装ができてしまう．
      }．
      こうした考察から多くの言語には型システムによる静的な検査が搭載されており，
      我々のコーディングを型検査器が支えてくれるようになっている．
      \SATySFi;も，そんな言語のひとつである．
    }
  >
  +subsection{タプル}<
    +p{
      \dfnje{タプル}{tuple}とは “複数の式を並べてひとまとめにした式” であり，
      数学的に言えば直積に相当するものだ．タプルは式として次のような形をもつ：

      \d-codem{
        (\metasub(${1}){expr}, ${\ldots}, \metasub(${n}){expr})
      }%

      ただし ${n \geq 2}．
      各式\codem{\metasub(${i}){expr}}が\type(Type.tymtausub ${i});をもつとき，
      上記のタプルは以下のような型をもつ：

      \quote{
        \type(Type.(product [tymtausub ${1}; tymtausub ${2};
          of-math ${\cdots}; tymtausub ${n}]));
      }%

      代表的な用途として，“複数の値を返り値にしたい時” がある．
      例として，2つの整数を受け取ってその除算の商と剰余を一緒に返す函数\codem{div-rem}を定義してみる：

      \d-code(```
        let div-rem m n =
          (m / n, m mod n)
      ```);%

      こうして定義した\codem{div-rem}には
      \type(Type.(int --> (int --> product [int; int])));型がつく\footnote{
        型の記法では，${\ast} は ${\to} より結合が強いとする．
        すなわちここでは
        \type(Type.(int --> (int --> synt-paren (product [int; int]))));
        を指す．
      }．
      一方で，これを使う側はどうしたらよいのだろう？\quad;
      このために，タプルを “分解” する方法が用意されている．
      \dfnje{パターンマッチ}{pattern matching}と呼ばれる構文である．
      パターンマッチは条件分岐を強化したようなもので，
      “値の形” によって分岐させる機構である．
      \codem{div-rem}を用いて，
      “第1引数の整数以上の値にするには第2引数を少なくとも何倍すればよいか” を返す函数
      \codem{make-exceed}を定義してみる：

      \d-code(```
        let make-exceed n q =
          match div-rem n q with
          | (m, 0) -> m
          | (m, _) -> m + 1
      ```);%

      ここで登場した次のような構文の式がパターンマッチを実現する
      \dfnje{match式}{match-expression}である：

      \d-codem{
        match \meta{expr} with
        \| \metasub(${1}){pat} -\> \metasub(${1}){expr} \| ${\cdots} \|
          \metasub(${n}){pat} -\> \metasub(${n}){expr}
      }%

      ただし ${n \geq 1}で，\codem{with}の直後の\codem{\|}は省略してもよい．
      各\codem{\metasub(${i}){pat}}は\dfnje{パターン}{pattern}と呼ばれるものであり，
      “値の形” を表す．
      パターンの中には変数または\dfnje{ワイルドカード}{wildcard}である\codem{\_}を含めてよく，
      そこは “どんな形でもマッチする” ものと扱われる．
      match式は，まず\codem{\meta{expr}}を評価し，その結果得られた値が
      各パターン\codem{\metasub(${i}){pat}}のどれに合致する “形” をしているかを
      先に挙げたパターンほど優先で選択し，パターン中の変数を該当箇所の実際の値に束縛してから，
      それに対応する式\codem{\metasub(${i}){expr}}を評価する．
      上記の例では，\codem{div-rem}が返すタプルの2番目の値，
      つまり剰余に相当する部分が\codem{0}である場合は，
      変数\codem{m}をタプルの1番目の値に束縛し，そのパターンに対応する式である\codem{m}を返す．
      つまり，この場合は単に割った商を返している．
      一方で，最初のパターンにマッチしなかった場合は，
      2番目のパターンにマッチさせ，同様に変数\codem{m}を用いて商を取り出し，
      それに\codem{1}を加えて返す．
      パターンの順番は重要である．もし上の例で
      \codem{\| (m, _) -\> m + 1}を\codem{\| (m, 0) -\> m}よりも先に書いていたら，
      定義される\codem{make-exceed}は単に “商に${1}足して返す函数” になってしまう
      （つまり，\codem{n}が\codem{q}で割り切れる場合の返り値が異なる）．
      型の観点からは，各\codem{\metasub(${i}){expr}}の型はすべて一致する必要があり，
      その一致した型がmatch式全体のもつ型になる．
      また，パターンがひとつだけのmatch式
      \codem{match \meta{expr} with \metasub(${1}){pat} -\> \metasub(${1}){expr}}
      は\codem{let}を用いて

      \d-codem{
        let \metasub(${1}){pat} = \meta{expr} in \metasub(${1}){expr}
      }%

      という糖衣構文で書くことができる．別の例として
      “長さと平面座標を受け取り，その座標を ${+x} 方向に与えられた長さだけ移動させる函数”
      \codem{shift-x}を定義してみよう：

      \d-code(```
        let shift-x len point =
          let (x, y) = point in
          (x +' len, y)
      ```);%

      このように\codem{let}でタプルを分解できるのである．
      こうして定めた\codem{shift-x}は
      \type(Type.(length --> (product [length; length] --> product [length; length])));
      型をもつ．
      さらには，パターンを引数に直接書くこともできる．
      以下のように書いても，上での定義と等価に振舞う函数が定義できる：

      \d-code(```
        let shift-x len (x, y) =
          (x +' len, y)
      ```);%

      駆け足気味であったが，以上がタプルとパターンマッチの基礎である．
    }
  >
  +subsection{代数的データ型}<
    +p{
      \dfnje{代数的データ型}{algebraic data type, ADT}は，
      非常に大雑把に言えば “構成に独立な複数の方法があるデータ” を扱う型である．
      \dfnje{ヴァリアント型}{variant type}とか
      \dfnje{合併型}{union type}と呼ばれることもあり\footnote{
        「合併型」や “union type” は\dfn{Elm}などの言語で用いられる用語だが，
        型システムの議論ではこれらの語がよく似た別物を指すこともあるので注意を要する．
      }，
      数学的には直和に対応する．
    }
    +p{
      代数的データ型を扱う必要性を感じるために，
      まず「長方形または円からなる図形のデータを扱いたい」という場面を考える．
      長方形は対角線をなす2点を記録すればよく，
      円は中心座標と半径を記録すればよいだろう．
      それぞれ図形に対して一意的な表現方法にはなっていないが，それは特に問題にせず，
      単にデータとして不足なく保持できればよい．
      ここまでに紹介した言語機能を用いて長方形と円を一緒に扱うナイーヴな方法のひとつは，
      \type(Type.(product [string; length; length; length; length]));
      という型のタプルを用いる方法だ．
      ${\tuple{|x_1|y_1|}} と ${\tuple{|x_2|y_2|}} とが対角線をなす長方形は
      \codem{(\`rectangle\`, \metasub(${1}){x}, \metasub(${1}){y},
        \metasub(${2}){x}, \metasub(${2}){y})}
      で，
      ${\tuple{|x|y|}} を中心とする半径 ${r} の円は
      \codem{(\`circle\`, \meta{x}, \meta{y}, \meta{r}, 0pt)}
      でそれぞれ表すことにするのである．
      しかし，これはかなり “荒っぽい” 方法であり，いくつもの問題を孕んでいる．
      まず\codem{(\`hoge\`, 2pt, -5pt, 0pt, 3pt)}のような
      “意味をなさないデータ” が同じ型で作れてしまう．
      勿論図形を受け取る各函数でそのデータが正しいか逐一確認することはできるが，
      複雑な処理では確認を忘れてしまうことも十分ありうるし，
      何より正しくないデータだった場合に実行時エラーにするしかないのは不便である．
      このほか，図形が格納された変数\codem{geom}に対して
      \codem{let (_, _, _, x, _) = geom in ${\cdots}}
      として\codem{x}に値を取り出せるが，この\codem{x}は図形ごとに
      全然違う役割を担っている．
      このような操作が安易にできてしまうと，複雑化するにしたがって見つけにくい実装のミスに繋がる．
    }
    +p{
      代数的データ型を用いれば，このような状況をはるかにスマートに扱える．
      まずは具体例として，上で挙げた図形を扱うための型
      \type(Type.(base-type {geometry}));を定義してみる：

      \d-code(```
        type geometry =
          | Rectangle of (length * length) * (length * length)
          | Circle    of (length * length) * length
      ```);%

      この定義は，新たに定義する\type(Type.(base-type {geometry}));型に於いて

      \listing{
        * ${\tuple{|x_1|y_1|}} と ${\tuple{|x_2|y_2|}} とが対角線をなす長方形は
          \codem{Rectangle((\metasub(${1}){x}, \metasub(${1}){y}),
            (\metasub(${2}){x}, \metasub(${2}){y}))}
          という形で扱われる

        * ${\tuple{|x|y|}} を中心とする半径 ${r} の円が
          \codem{Circle((\meta{x}, \meta{y}), \meta{r})}
          という形で扱われる

        * この形以外のデータは扱わない
      }%

      ということを宣言している．
      この宣言以降，\codem{Rectangle \meta{expr}}および
      \codem{Circle \meta{expr}}で
      \type(Type.(base-type {geometry}));型のつく式を書ける．
      一般に代数的データ型の定義は以下のような構文で宣言される：

      \d-codem{
        type \metasub(${1}){'a} ${\cdots} \metasub(${m}){'a} \meta{tyname} =
          \| \metasub(${1}){Ctr} of \metasub(${1}){ty}
          \| ${\cdots}
          \| \metasub(${n}){Ctr} of \metasub(${n}){ty}
      }%

      ただし ${m \geq 0} かつ ${n \geq 1}で，また\codem{=}の直後の\codem{\|}は省略でき，
      宣言される型の名前\meta{tyname}に使えるのは変数名に使える文字列である．
      各\codem{\metasub(${i}){Ctr}}は\dfnje{コンストラクタ}{constructor}と呼ばれ，
      コード中の相異なる文字列である．
      コンストラクタとして使えるのは

      \listing{
        * 1文字目はラテン大文字
        * 2文字目以降は大小ラテン文字，数字，ハイフンのいずれか
      }%

      を満たす1文字以上の長さの文字列である．
      \codem{\meta{Ctr} of \meta{ty}}は
      \codem{\meta{Ctr}}と書く構文もあり，
      これは\codem{\meta{Ctr} of unit}と等価である．
      \type(Type.unit);型は唯一の値\codem{()}をもつ型で，
      \ref-subsection(`imperative`);で説明するような手続き的処理の返り値や，
      手続き的処理を行なう函数の引数などにダミー的に利用される\footnote{
        このような用法を\dfnje{サンク}{thunk}などと呼ぶ．
      }．
      \codem{\metasub(${j}){'a}}は\dfn{型引数}と呼ばれるものだが，
      今は触れず，${m = 0} とする．
    }
    +p{
      さて，代数的データ型とそれに属するデータの作り方はわかったが，
      そのデータをどうやって使えばいいのだろう？\quad;
      実は代数的データ型のデータも，タプルと同様にパターンマッチによって分解する．
      例として，上で定義した\type(Type.(base-type {geometry}));型のデータを受け取って
      その（平方センチメートル単位の）面積を浮動小数点数で返す函数
      \codem{area} : \type(Type.(base-type {geometry} --> float));を定義してみる：

      \d-code(```
        let pi = 3.1415926535

        let length-abs len =
          if len <' 0pt then 0pt -' len else len

        let area geom =
          match geom with
          | Rectangle((x1, y1), (x2, y2)) ->
              let w = (length-abs (x1 -' x2) /' 1cm) in
              let h = (length-abs (y1 -' y2) /' 1cm) in
                w *. h

          | Circle(_, r) ->
              let rf = r /' 1cm in
                rf *. rf *. pi
      ```);%

      与えられた図形が長方形なのか円なのかパターンマッチで分岐して処理している．
      \codem{\meta{Ctr}}が何らかのデータ型に属するものとして定義済みのコンストラクタであるとき，
      \codem{\meta{Ctr} \meta{pat}}がパターンとして使え，
      \codem{\meta{Ctr} \meta{v}}の形の値が
      （\codem{\meta{v}}が\codem{\meta{pat}}にマッチするときに）マッチするのである．
      上で定義した\codem{area}を実際に使ってみよう：

      \d-code-and-block(```
        +p{ Answer:
          \show-float(area (Rectangle((1cm, 2.4cm), (-3cm, 10cm)))); }
        +p{ Answer:
          \show-float(area (Circle((5cm, 0cm), 2cm))); }
      ```)(open Sample in '<
        +p{ Answer:
          \show-float(area (Rectangle((1cm, 2.4cm), (-3cm, 10cm)))); }
        +p{ Answer:
          \show-float(area (Circle((5cm, 0cm), 2cm))); }
      >);%

      長方形と円のそれぞれについて正しく面積が計算できていることがわかる．
    }
    +p{
      \SATySFi;には，いくつかの代数的データ型がデフォルトで備わっている．
      特に組版処理特有のデータは次のように定義される\type(Type.color);型である：

      \d-code(```
        type color =
          | Gray of float
          | RGB  of float * float * float
          | CMYK of float * float * float * float
      ```);%

      \codem{Gray}，\codem{RGB}，\codem{CMYK}は
      それぞれグレイスケール，RGB，CMYKの色空間で色を表現するためのコンストラクタで，
      PDFの仕様に於ける
      \code(`/DeviceGray`);，\code(`/DeviceRGB`);，\no-break{\code(`/DeviceCMYK`);}に
      それぞれ対応する．
      引数の各数値は\codem{0.}で最小，\codem{1.}で最大を表し，
      例えば\codem{Gray(0.)}は黒，\codem{Gray(1.)}は白，
      \codem{RGB(1., 0., 0.)}は赤，といった具合である．
      この\type(Type.color);型は，\ref-chapter(`graphics`);で紹介する
      グラフィックス関連の種々の記述で使われるほか，
      \pkg{color}パッケージではこの型を用いていくつかの頻出の色が定義されている．
    }
  >
  +subsection{再帰函数}<
    +p{
      この節では\dfnje{再帰函数}{recursive function}を扱う．
      再帰函数とは，簡単に言えば
      “定義中で自分自身を呼び出すように記述されている函数” である．
      再帰函数の説明としてあまりにも月並みではあるが，
      例として整数の階乗を求める函数\codem{fact}を定義する
      （ただし，ここでは ${0\! \defeq 1} と定めるものとする）：

      \d-code(```
        let-rec fact n =
          if n <= 0 then 1 else n * fact (n - 1)
      ```);%

      \codem{let}の代わりに\codem{let-rec}から始める構文である．
      とりあえず使ってみて，結果が期待どおりであることを確認しよう：

      \d-code-and-block(```
        +p{ Answer: \show-int(fact 6); }
      ```)(open Sample in '<
        +p{ Answer: \show-int(fact 6); }
      >);%

      再帰函数の定義は，一般には以下のような形をしている：

      \d-codem{
        let-rec \meta{f} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} =
          \metasub(${1}){expr}
        in
          \metasub(${2}){expr}
      }%

      \codem{let}の場合とは違い，\codem{\metasub(${1}){expr}}の中でも
      定義しようとしている\codem{\meta{f}}が使えるのが特徴である．
      ただし，この\codem{let-rec}による定義では，
      糖衣構文を “はがした” 上で最終的に\codem{\meta{f}}が束縛される式は
      函数の形の式\codem{(fun \meta{x} -\> \meta{expr})}でなければならず，
      したがって\codem{let-rec n = n + 1}のような定義は書けないようになっている．
      さて，もとの例である\codem{fact}の定義を理解しよう．
      これはたしかに\codem{fact \meta{n}}で階乗 ${n\!} を返すような定義になっており，
      慣れれば一目瞭然なのだが，
      “プログラムを手続き的に理解するという観念に拘束されている人” には少し飛躍があるかもしれない．
      再帰函数はいわゆる函数型プログラミングを最大に特徴づける重要な点とさえ言えるので是非とも理解されたい．
      再帰を理解する有用な直観は，いわゆる数学的帰納法によく似ている．
      すなわち，“より小さいものに対する解決がより大きいものの解決に使える” のである．
      上記の\codem{fact}の定義は，次のような直観に基づいて理解できる：

      \listing{
        * 与えられた引数が\codem{0}（またはそれ未満）の場合は，
          返り値として即座に\codem{1}を返してよい．

        * 与えられた引数\codem{\meta{n}}が\codem{1}以上の場合，
          返すべき値は\codem{\meta{n}}と\codem{\meta{n} - 1}の階乗との積である．
          したがって，\codem{\meta{n} - 1}の階乗を（\codem{fact}自分自身を呼び出すことで）計算し，
          その計算結果に\codem{\meta{n}}を掛けて返り値とすればよい．
      }%

      或る意味では，階乗函数の（数学的な）定義：

      \align[
        ${| 0\! |\defeq 1 |};
        ${| n\! |\defeq n \times \paren{n - 1}\! \text!{\quad;(${n \geq 1})} |};
      ];%

      に近い記述ができているとも言える．
      ともかく，「再帰は再帰がわかるとわかる」のだ．
    }
    +p{
      さて，ここで少し\dfnje{多相型}{polymorphic type}の話をしよう．
      まず以下のような函数を見てほしい：

      \d-code(```
        let proj1 tuple =
          let (x, _) = tuple in x
      ```);%

      この函数につく型はなんだろうか？\quad;
      ひとまず，例えば\type(Type.(product [int; string] --> int));
      などはつくはずであるが，よくよく見直すと
      \type(Type.(product [tymtausub ${1}; tymtausub ${2}] --> tymtausub ${1}));%
      という形の型は全部つくということがわかる．
      これを反映して，let多相では上記の\codem{proj1}に

      \quote{
        \type(Type.(forall ${\alpha} (forall ${\beta} (product [tymalpha; tymbeta] --> tymalpha))));
      }%

      という型をつける．ここでの ${\alpha} や ${\beta} は\dfnje{型変数}{type variable}と呼ばれ，
      実際に\codem{proj1}が使われるたびに（“整合する” 限りに於いて）適切な型をあてはめて使われる．
      例えば上記の\codem{proj1}の定義以降で
      \codem{(proj1 (1cm, 2cm), proj1 (\`foo\`, 1))}などと書いても
      （ふたつの\codem{proj1}は異なる型の引数を受け取っているにもかかわらず）問題なく型がつく．
      多相型をつける一般的な規則を述べると長くなるため事細かには述べないが，
      基本的にはletで束縛される変数の型に関して型推論の結果特に型が決定しない部分は型変数として一般化され，
      多相型がつくという仕組みになっている．
    }
    +p{
      多相型について把握してもらったところで，代数的データ型で一旦無視していた型引数の説明をしよう．
      型引数は，多相な代数的データ型を定義するための機構である．
      例として，最初から備わっている代数的データ型のひとつである
      \type(Type.(option tymalpha));型について見てみる．
      この型は，以下のように定義できるものだ：

      \d-code(```
        type 'a option = None | Some of 'a
      ```);%

      \codem{'a}というひとつの型引数をとる定義である．
      型引数は，その代数的データ型の定義中で型として使うことができる．
      \type(Type.(option tymalpha));型は，直観的には
      “\type(Type.tymalpha);型の値ひとつか，或いは何もないか” を表現する型である．
      もう少し具体的な用途を挙げて直観を説明するなら，
      “成功した時は\type(Type.tymalpha);型の値を返したいが，失敗するかもしれない函数”
      の返り値の型として使ったりする．
      例えば “実行時に失敗しない安全な除算” は以下のように定式化できる：

      \d-code(```
        let div-safe m n =
          if n == 0 then None else Some(m / n)
      ```);%

      この\codem{div-safe}は\type(Type.(int --> (int --> option int)));型をもつ．
    }
    +p{
      \codem{div-safe}は型引数に具体的に当てはまる型が\type(Type.int);型に決定していたが，
      重要なのはこれを多相なままにできるということである．

      \d-code(```
        let from-option d opt =
          match opt with None -> d | Some(v) -> v
      ```);%

      \codem{from-option}は，第2引数に与えられた値が\codem{None}のときは “デフォルト値” として
      第1引数\codem{\meta{d}}を返し，\codem{Some(\meta{v})}の形のときはその\codem{\meta{v}}を
      取り出して返すことで\type(Type.(option tymtau));型のデータを
      \type(Type.tymtau);型へと “潰す” 函数である．
      これは\type(Type.tymtau);という型によらず同様であり，実際
      この\codem{from-option}には\type(Type.(forall ${\alpha} (tymalpha --> (option tymalpha --> tymalpha))));
      という多相型がつく．
    }
    +p{
      さらに代数的データ型の話を続けよう．
      実は，代数的データ型の重要な特徴として，再帰的なデータを扱う型を定義できるというものがある．
      例として，二分木を扱う代数的データ型は以下のように定義できる：

      \d-code(```
        type 'a bin-tree =
          | Empty | Node of 'a * 'a bin-tree * 'a bin-tree
      ```);%

      \type(Type.(ctr-type {bin-tree} [tymalpha]));型の定義の中に
      \type(Type.(ctr-type {bin-tree} [tymalpha]));型自身が現れている．
      この型に基づく二分木を文字列に変換する函数\codem{show-tree}は
      以下のように定義できる：

      \d-code(```
        let-rec show-tree pr tr =
          match tr with
          | Empty -> `_`
          | Node(x, trL, trR) ->
              `(` ^ (pr x) ^ #` `# ^
                (show-tree pr trL) ^ #` `# ^ (show-tree pr trR) ^ `)`
      ```);%

      この\codem{show-tree}につく型は
      \type(Type.(forall ${\alpha} ((tymalpha --> string) -->
        (ctr-type {bin-tree} [tymalpha] --> string))));
      である．引数\codem{pr}も函数であることに注目されたい．
      \codem{show-tree}は函数を受け取ってそれを使う函数になっており，
      このような函数を\dfnje{高階函数}{higher-order function}と呼ぶ．
      型も，それに対応して\type(Type.(tymalpha --> string));が引数側にきている．
    }
    +p{
      最も汎用性の高い再帰的なデータ型は，おそらく\dfnje{リスト}{list}だろう．
      リストとは\codem{[3\; 1\; 4\; 1\; 5\; 9\; 2]}といったように
      基本的に “同じ種類データが有限個並んだもの” であり，
      \type(Type.tymtau);型のデータが並んだリストを
      \type(Type.(list tymtau));型がつくものとして扱うのだが，
      リストを構築・分解する方法の直観とは少し飛躍がある：\quad;
      リストの構築方法は

      \listing{
        * 空リスト\codem{[]}
        * 要素\codem{\meta{x}}とリスト\codem{\meta{xs}}の結合\codem{\meta{x} :: \meta{xs}}
      }%

      の2種類があり，\codem{[3\; 1\; 4\; 1\; 5\; 9\; 2]}は
      \codem{3 :: (1 :: (4 :: (1 :: (5 :: (9 :: (2 :: []))))))}の糖衣構文なのである\footnote{
        \codem{::}は右結合なので，ここでつけている括弧は全て省略できる．
      }．
      要するに，リストとは（模擬的には）以下で定義される代数的データ型に相当する：

      \d-code(```
        type 'a list = [] | (::) of 'a * 'a list
      ```);%

      リストに対する簡単な処理をいくつか見てみる．
      まずリストを受け取ってその長さを返す函数\codem{list-length}は以下のとおり：

      \d-code(```
        let-rec list-length l =
          match l with
          | []      -> 0
          | x :: xs -> 1 + list-length xs
      ```);%

      ふたつのリストを結合する函数\codem{list-append}は以下のとおり：

      \d-code(```
        let-rec list-append l1 l2 =
          match l1 with
          | []      -> l2
          | x :: xs -> x :: list-append xs l2
      ```);%

      リストを前後反転する函数\codem{list-reverse}は，
      前2つの例に比べて少し技巧的だが以下のように実装できる：

      \d-code(```
        let list-reverse l =
          let-rec aux acc l =
            match l with
            | []      -> acc
            | x :: xs -> aux (x :: acc) xs
          in
          aux [] l
      ```);%

      かなり駆け足の説明のため基礎的な函数のみの紹介となってしまったが，
      リストに対する操作，例えばマップ函数や畳み込み函数は，
      内容の充実した函数型プログラミングの入門書では必ず触れるものなので，
      是非参照されたい．
      なお，リストに対する操作は\pkg{list}パッケージでいくつも定義されており，
      ここで例示した\codem{list-length}，\codem{list-append}，\codem{list-reverse}も
      \codem{List.length}，\codem{List.append}，\codem{List.reverse}として
      それぞれ実装されている．
    }
    +p{
      \ref-chapter(`getting-started`);で登場した\type(Type.itemize);型も，
      実はあらかじめ定義されている以下のような再帰的な代数的データ型である：

      \d-code(```
        type itemize = Item of inline-text * itemize list
      ```);%

      そして，\codem{\\listing}などのコマンドに渡される

      \d-code(```
        { * 東京
            ** 本郷
            ** 弥生
            ** 浅野
            ** 駒場
          * 千葉
            ** 柏 }
      ```);%

      という記述は，以下のような構造の糖衣構文である：

      \d-code(```
        (Item(` `, [
          Item({東京}, [
            Item({本郷}, []);
            Item({弥生}, []);
            Item({浅野}, []);
            Item({駒場}, []); ]);
          Item({千葉}, [
            Item({柏}, []); ]);
        ]))
      ```);%

      \codem{\\listing}などのコマンドは，この再帰的なデータ構造の上を
      走査して組版処理しているのである．
    }
  >
  +subsection{レコード}<
    +p{
      \dfnje{レコード}{record}は，タプルと同様に “複数の式をまとめて扱う機構” なのだが，
      タプルがデータを “何番目のデータか” に基づいて構築・分解していたのに対し，レコードでは
      それぞれのデータに\dfnje{ラベル}{label}がつけられ，これに基づいて構築したり取り出したりする．
      おおよそ，C言語でいうところの構造体にあたる概念である．
      例として，人物の情報を扱うレコードをまず掲げよう：

      \d-code(```
        (| given-name = `Takashi`; family-name = `Suwa`; age = 25; |)
      ```);%

      ここでの\codem{given-name}，\codem{family-name}，\codem{age}がラベルである．
      ラベルに使える文字列は変数名に使えるそれと同じ範囲である．
      レコード\codem{\meta{r}}からの内容の取り出しは
      \codem{\meta{r}\#\meta{label}}という式によって行なう．
      例えば上記のレコードが\codem{r-tsuwa}という変数に格納されているとき，
      \codem{r-tsuwa\#age}は\codem{25}へと評価される．
      実は，レコードは\SATySFi;で文書を書くユーザならほぼ全員使っているはずである．
      というのも，大抵のクラスファイルでは\codem{document}の直後に文書に関する情報を
      レコードで渡すようなインターフェイスになっているからだ．
      そう，以下の\codem{(\| ${\cdots} \|)}の部分はレコードだったのである．

      \d-code(```
        @require: stdjareport

        document (|
          title = {はじめての文書};
          author = {組 版太郎};
        |) '<
        （以降略）
      ```);%
    }
    +p{
      レコードのラベルという仕組みは
      タプルに比べて各要素がどのような役割を果たしているかが明瞭であり，
      プログラムのドキュメント性を向上させる効能があるが，
      型つけに関してさらに顕著な違いがある．
      \SATySFi;でのレコードに関する型つけ規則は，
      \dfn{SML\#}を基礎づける型システム \cite[`Ohori1995`];を大々的に参考にしている．
      この型システムについて定義をすべて述べるのはあまりにも長いので，
      簡素に直観だけを与える．詳細は元論文 \cite[`Ohori1995`];を参照されたい．
      まず，基本的にレコード：

      \d-codem{
        (\| \metasub(${1}){label} = \metasub(${1}){expr}\; ${\cdots}\;
            \metasub(${n}){label} = \metasub(${n}){expr}\; \|)
      }%

      は，各式\codem{\metasub(${i}){expr}}に型\type(Type.tymtausub ${i});がつく下で

      \quote{
          ${\Type.record-paren{
            \text!{\metasub(${1}){label}} : \mtype!(Type.(tymtausub ${1}))\;
            \ \cdots\;
            \ \text!{\metasub(${n}){label}} : \mtype!(Type.(tymtausub ${n}))
          }}
      }%

      という型をつけて扱う．レコードそのものの型つけは単純なのだが，
      重要なのはラベルへのアクセスに関する型つけである．
      レコードを受け取り，そのレコードのラベル\codem{foo}にアクセスする函数を考える：

      \d-code(```
        let f r = r#foo + 1
      ```);%

      この函数\codem{f}にどんな型をつければよいかをまず素朴に考えよう．
      この函数の式が型の制約として要請するのは，
      \codem{r}という変数が束縛されているレコードが\codem{foo}というラベルをもち，
      かつそれに対応する値が\type(Type.int);型であるということだけである．
      この函数を\SATySFi;では（SML\#に倣って）

      \quote{
        \type(Type.(forall-kinded ${\alpha} [({foo}, int)] (tymalpha --> int)));
      }%

      という型をつけて扱う．これは ${\alpha} が一般化されている或る種の多相型なのだが，
      重要なのは「:: \type(Type.(record [({foo}, int)]));」の部分であり，
      これは ${\alpha} が（任意の型ではなく）ラベルfooに\type(Type.int);型をもつ
      レコードの型のみを動く型変数であるということを記述している．
      同様にして

      \d-code(```
        let g r =
          let (x, _) = r#bar in r#foo + (round x)
      ```);%

      で定義される\codem{g}には以下のような型がつく：

      \quote{
        \type(Type.(forall ${\beta} (forall-kinded ${\alpha} [
          ({foo}, int);
          ({bar}, product [float; tymbeta]);
        ] (tymalpha --> int))));
      }%

      一般的な説明は煩雑なので省くが，おおよそこのような仕組みでレコードに関して
      多相型がつけられる．

    }
  >
  +subsection?:(`imperative`){手続き}<
    +p{
      いわゆる函数型言語ではあるものの，\SATySFi;にも手続き的処理を行なう機構は備わっている．
      すなわち，書き換え可能な変数に相当する\dfnje{可変参照}{mutable reference}である．
      可変参照は，次のような構文で宣言する：

      \d-codem{
        let-mutable \meta{x} \<- \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      \codem{\meta{x}}が宣言される可変参照であり，
      \codem{\metasub(${1}){expr}}がその初期値，
      \codem{\metasub(${2}){expr}}が\codem{\meta{x}}の使えるスコープである．
      可変参照は基本的には通常の変数と同様の扱いであるものの，
      \type(Type.(tymtau));型の値が格納される可変参照は
      \type(Type.(ref tymtau));型がつけられる．
      可変参照\codem{\meta{x}}の現在の内容は\codem{!\meta{x}}で取得することができ，
      また内容を破壊的に書き換える処理は，
      新たに格納させる内容に評価される式を\codem{\meta{expr}}として
      \codem{\meta{x} \<- \meta{expr}}
      と書く．この式が評価されて\codem{\meta{x}}の内容が上書きされると，
      式全体はユニット値\codem{()}となる．
    }
    +p{
      可変参照は，章節番号の挿入など，“本質的に手続き的な処理” をクラスファイル内で扱うのに利用されているので，
      各種クラスファイルの中を覗くと多くの用例が確認できるだろう．
      ただし，多くの場合可変参照を多用するとプログラムの挙動を把握困難にする要因となる\footnote{
        だからこそいわゆる函数型プログラミングの流儀は
        破壊的代入を積極的に避けるのである．
      }ので，
      止むを得ない場合を除いてできる限り使わないように心がけた方が良さそうである．
    }
  >
  +subsection?:(`arithmetic`){算術に関するプリミティヴ}<
    +p{
      主な “算術演算” 用のプリミティヴについてまとめて紹介する：

      \vals-explain({|+|-|\*|})(tyarithI) {
        整数の加算，減算，乗算．
      }%
      \vals-explain({|/|mod|})(tyarithI) {
        整数の除算と剰余．
        \codem{mod}は通常の変数名のように見えるが，例外的に2項演算子である．
        いずれも第2引数に\codem{0}が与えられた場合は実行時エラーとなる．
      }%
      \vals-explain({|==|\<\>|})(tycompI) {
        整数の等号と不等号．
      }%
      \vals-explain({|\>|\<|\>=|\<=|})(tycompI) {
        “大なり”，“小なり”，“大なりイコール”，“小なりイコール”．
      }%

      % -- 真偽値 --
      \vals-explain({|\&\&|\|\||})(tylogical) {
        連言と選言．
      }%
      \val-explain({not})(Type.(bool --> bool)) {
        否定．
      }%

      % -- 浮動小数点数 --
      \val-explain({float})(Type.(int --> float)) {
        整数を浮動小数点数に変換する．
      }%
      \val-explain({round})(Type.(float --> int)) {
        浮動小数点数を，小数部分を切り捨てて整数に変換する．
        引数が正負無限やNaN，あるいは小数部分を切り捨てた整数が\type(Type.int);型で
        表現不可能なときの結果は未定義．
      }%
      \vals-explain({|+.|-.|\*.|/.|})(tyarithF) {
        浮動小数点数の加算，減算，乗算，除算．
      }%
      \vals-explain({|sin|cos|tan|asin|acos|atan|})(tysine) {
        正弦，余弦，正接函数，およびアークサイン，アークコサイン，アークタンジェント
        （すなわち正弦，余弦，正接函数の “逆函数”）．
      }%
      \val-explain({atan2})(Type.(float --> (float --> float))) {
        \codem{atan2 \meta{y} \meta{x}}で
        \codem{\meta{y} /. \meta{x}}のアークタンジェントを返すが，
        \codem{\meta{y}}と\codem{\meta{x}}の符号が象限の決定に用いられる．
        返される値は ${\mathord{-}\pi} から ${\pi} の間の値である．
      }%

      % -- 長さ --
      \vals-explain({|+'|-'|})(Type.(length --> (length --> length))) {
        長さの加算と減算．
      }%
      \val-explain({\*'})(Type.(length --> (float --> length))) {
        長さのスカラー倍．
      }%
      \val-explain({/'})(Type.(length --> (length --> float))) {
        長さの “除算”．
      }%
      \vals-explain({|\>'|\<'|})(Type.(length --> (length --> bool))) {
        長さの “大なり” と “小なり”．
      }%

      % -- 文字列 --
      \val-explain({^})(Type.(string --> (string --> string))) {
        文字列の結合．
      }%
      \val-explain({arabic})(Type.(int --> string)) {
        整数を十進文字列に変換する．
      }%
      \val-explain({show-float})(Type.(float --> string)) {
        浮動小数点数を十進文字列に変換する．
      }%
      \val-explain({string-same})(Type.(string --> (string --> bool))) {
        文字列の等価性の判定．
        バイト列として等価かどうかの判定であり，
        Unicodeによって規定された正規化等は行なわない．
      }%
      \val-explain({string-sub})(Type.(string --> (int --> (int --> string)))) {
        \codem{string-sub \meta{s} \meta{i} \meta{l}}で
        文字列\codem{\meta{s}}の第\codem{\meta{i}}番目の文字を先頭とする
        長さ\codem{\meta{l}}の部分文字列を取り出す．
        文字数はUnicodeコードポイント単位．
        \codem{\meta{i}}と\codem{\meta{l}}による
        指定が部分文字列の範囲でない場合は実行時エラーが出る．
      }%
      \val-explain({string-length})(Type.(string --> int)) {
        与えられた文字列がUnicodeコードポイント単位で何文字かを返す．
      }%
      \val-explain({string-unexplode})(Type.(list int --> string)) {
        与えられた整数列の各整数をUnicodeコードポイントと解釈した文字列を返す．
        Unicodeコードポイントの範囲にない整数が与えられた場合の動作は未定義．
      }%
      \val-explain({embed-string})(Type.(string --> inline-text)) {
        文字列をインラインテキストに変換する．
      }%
      \val-explain({split-into-lines})%
        (Type.(string --> list (product [int; string]))) {
          与えられた文字列を各行に分解してリストを返す．
          返されるリストの各要素\codem{(\meta{i}, \meta{s})}は
          “インデントが\codem{\meta{i}}個挿入された内容文字列\codem{\meta{s}}の行”
          に相当する．
        }%

       \val-explain({!})%
         (Type.(forall ${\alpha} (ref tymalpha --> tymalpha))) {
           \codem{!\meta{r}}で可変参照\codem{\meta{r}}の参照する現在の値を返す．
         }%
       \val-explain({::})(Type.(forall ${\alpha}
         (tymalpha --> (list tymalpha --> list tymalpha)))) {
           リストの “コンス”，すなわち第1引数を第2引数のリストの先頭につけてできるリストを返す．
         }%
       \val-explain({\|\>})(Type.(forall ${\alpha} (forall ${\beta}
         (tymalpha --> ((tymalpha --> tymbeta) --> tymbeta))))) {
           前後逆の函数適用，すなわち
           \codem{\meta{x} \|\> \meta{f}}で
           \codem{\meta{f} \meta{x}}に同じ．
           ただし，式\codem{\meta{x}}と\codem{\meta{f}}の評価に
           ともに “副作用” がある場合は評価順序の逆転に注意を要する．
         }%
       \val-explain({display-message})(Type.(string --> unit)) {
         与えられた文字列を1行として標準出力に表示する．
       }%
    }
  >
  +subsection?:(`diff-from-ocaml`){OCamlとの顕著な差異}<
    +p{
      すでに述べたように
      プログラミング言語としての\SATySFi;は
      OCamlにかなり近いものとなっているが，
      非互換な違いがいくつか顕著にある．
    }
    +desc{変数名}{
      おそらくコードの見た目上これが最も目につく違いである．
      変数名はラテン小文字から始まり，
      2文字目以降は大小ラテン文字，数字，ハイフンのいずれかでなければならない．
      アンダースコア（\codem{_}）や
      引用符（\codem{'}）は使えないことに注意．
    }
    +desc{再帰函数の定義}{
      再帰函数の定義には，OCamlの\code(`let rec`);の代わりに
      \codem{let-rec}を用いる．これで1トークンである．
    }
    +desc{型コンストラクタの構文}{
      \SATySFi;では，型コンストラクタ\codem{\meta{tyconstr}}の “適用” は
      \codem{\metasub(${1}){ty} ${\cdots} \metasub(${n}){ty} \meta{tyconstr}}
      という形で書く．これはOCamlの
      \codem{(\metasub(${1}){ty}, ${\ldots}, \metasub(${n}){ty}) \meta{tyconstr}}
      および ${n = 1}の場合の
      \codem{\metasub(${1}){ty} \meta{tyconstr}}
      という形の構文とは明確に異なる．そのかわり，
      OCamlでの\code(`int list list`);のような括弧を省いた “適用” を書くことはできず，
      必ず\codem{(int list) list}と括弧をつけることになる．
    }
    +desc{コンストラクタ}{
      \SATySFi;では，ヴァリアント型のコンストラクタはすべて1引数である．
      \codem{None}のように引数のないコンストラクタの使用は
      \codem{None()}のようにユニット値が省略されているものとして扱われているほか，
      OCamlでは

      \d-code(```
        type foo = Foo of int * int
      ```);%

      と

      \d-code(```
        type foo = Foo of (int * int)
      ```);%

      とで定義される型が異なるが，\SATySFi;では完全に一致する．
    }
    +desc{レコード}{
      まずレコード式を囲む括弧が
      \code(`{`); ${\cdots} \code(`}`);
      の代わりに
      \codem{(\| ${\cdots} \|)}である\footnote{
        これは\codem{\{ ${\cdots} \}}の記法を
        インラインテキストのために明け渡したからである．
      }．
      また，レコード型はnominalではなくstructuralであり，
      したがってレコード式\codem{(\| ${\cdots} \|)}は
      それにつく型を\codem{type ${\cdots}}で宣言せずとも
      書くことができる．
      これは\SATySFi;の型システムがレコードに関して
      \dfn{SML\#}と同様のもの \cite[`Ohori1995`];
      を採用しているからである（詳細は元論文を参照せよ）．
      これに加え，
      OCamlのように特定のフィールドをmutableにするような機能はなく，
      必ず全てのフィールドがimmutableである．
    }
    +desc{可変参照}{
      可変参照はOCamlのように多相函数\code(`ref`);で作るのではなく，

      \d-codem{
        let-mutable \meta{x} \<- \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      という構文で作るように限定されている．これはOCamlの

      \d-codem{
        let \meta{x} = ref \metasub(${1}){expr} in \metasub(${2}){expr}
      }%

      と同等である．破壊的代入も，OCamlのように\code(`:=`);ではなく，
      \codem{\meta{x} \<- \meta{expr}}と書く．
      \codem{\<-}が多相な2項演算子なのではなく，
      \codem{\meta{x} \<- \meta{expr}}全体が式をなすひとつの構文である．
    }
  >
>
