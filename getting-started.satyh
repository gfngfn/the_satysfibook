% -*- coding: utf-8 -*-
@import: settings

let getting-started = '<
  +p{
    ひとまず読者がすぐにさわれるものとして
    \index(`stdjareport`){\pkg{stdjareport}}クラスがあるので，
    これを土台に説明することとしよう．
    おそらく\LaTeX;の使用経験がある読者なら
    コード例を見ただけでおおよそ何を記述しているかは察しがつくであろうが，
    \LaTeX;（の一般的なクラスファイルが提供するマークアップ）と
    顕著に違いのある箇所についてはその都度述べておくことにした．
  }
  +p{
    なお，\LaTeX;の使用経験がない読者，
    そのうち特にMarkdownやreStructuredTextといった
    いわゆる軽量マークアップ言語に慣れ親しんだ読者からすれば
    「こんな冗長な記述をしなければならないのか」と感じられる点も見受けられるかもしれないが，
    組版処理中にエラーを生じないことを組版処理よりも前にできるだけ検出すること，
    ユーザにもコマンドが柔軟に定義できるようにすることを志向している都合上
    冗長にならざるを得ない部分も多いのだろうとひとまずは理解されたい．
  }
  +section{ファイルの種別と拡張子}<
    +p{
      \SATySFi;がユーザからの入力として直接的に扱うファイルには

      \listing{
        * \dfnje{\index(`ブンショファイル`){文書ファイル}}{document file}：
          文書の内容を記述するファイル
        * \dfnje{\index(`パッケージファイル`){パッケージファイル}}{package file}：
          コマンド定義などを記述するファイル
      }%

      の2種類がある．
      パッケージファイルのうちの一部には
      文書全体のマークアップ方法や体裁等を規定しているものがあり，
      これは\dfnje{\index(`クラスファイル`){クラスファイル}}{class file}と呼ぶ．
      パッケージファイルは拡張子を\path{.satyh}にしておく必要がある\footnote{
        実際には\path{.satyh}のほかに\path{.satyg}などの拡張子が扱われるが，
        今のところはひとまず\path{.satyh}だけと認識してもらって差し支えない．
        詳しくはテキストモードで扱う．
      }．
      文書ファイルの拡張子は現在のところ特に決まりはないが，
      慣習的には\path{.saty}を使用している．
      特別な理由がない限り，拡張子はこの\path{.saty}にすることを強く推奨する．
    }
  >
  +section{文書構造}<
    +p{
      全体構造として文書ファイルは以下のように記述する：
      \d-code(```
        @require: stdjareport

        document (|
          title = {サンプル文書};
          author = {組 版太郎};
        |) '<
          +chapter{はじめての章}<
            +p{
              \SATySFi;でのはじめての段落の記述です．
              段落は\dfn{ブロックコマンド}で実現されています．
            }
          >
        >
      ```);%
      インデントは構文解析上特に意味を持たず単に無視されるので，
      どのようにつけても構わない\footnote{
        勿論，習慣としては可読性のために括弧の入れ子構造に応じてインデントをつけておくことを薦める．
      }．
      文書ファイルの\codem{document}よりも手前の部分は，
      \LaTeX;に準じて便宜的に\dfnje{\index(`プリアンブル`){プリアンブル}}{preamble}と呼ぶことにしよう．
      ここに

      \d-code(```
        @require: （パッケージ名）
      ```);%

      と書くことでシステムにインストールされたパッケージを読み込める．
      パッケージの実体はソースコードが記述された単一のパッケージファイルであり，
      例えば\pkg{stdjareport}の本体は\path{stdjareport.satyh}というファイルなのだが，
      読み込みの指定は拡張子なしで書く（\path{.satyh}が自動で補われる）．
      文書ファイルと同じディレクトリに置いているような
      “ローカルな” パッケージファイルや分割ファイルは

      \d-code(```
        @import: （ファイルへの相対パス）
      ```);%

      で読み込む．やはり拡張子は自動で補われるので書かない\footnote{
        \codem{\@require}と\codem{\@import}で拡張子を省略する仕組みは
        単に手間を省くためにあるわけではない．
        補われる拡張子は\path{.satyh}とは限らないのである．
        これについては\ref-chapter(`future-work`);でのテキストモードについての説明で後述する．
      }．
    }
    +p{
      \codem{(\| ${\cdots} \|)}にタイトルや著者名など文書に必要な情報を与え，
      本文は\codem{'\< ${\cdots} \>}に記述する．
      この形式は\SATySFi;のGitHubリポジトリの
      \path{lib-satysfi/dist/packages/}に置いている他のクラスファイル，
      例えば\pkg{stdjabook}クラスなどでもおおよそ同様である．
      \SATySFi;での文書の記述は主に

      \listing{
        * \dfnje{\index(`ブロックテキスト`){ブロックテキスト}}{block text}：
          ページ方向に積み重なるもの
        * \dfnje{\index(`インラインテキスト`){インラインテキスト}}{inline text}：
          文字の進行方向へ連なるもの
      }%

      に分かれており，
      このうちインラインテキストが
      基本的に通常の文字列としてのテキストを書くことが想定されている箇所である．
      ブロックテキストは\codem{\< ${\cdots} \>}，
      インラインテキストは\codem{\{ ${\cdots} \}}で囲って記述する．
      ただし，上に掲げたコードで文書全体の内容にあたるブロックテキストを囲う開始側の括弧が
      \codem{\<}ではなく例外的に\codem{'\<}であることには注意されたい\footnote{
        詳細は後述するが，この括弧の前後で字句解析規則が変わりうる都合上，
        “コマンドの引数ではない部分” でブロックテキストを書くときは
        \codem{\<}ではなく\codem{'\<}にする必要がある．
        単に\codem{\<}と書くと不等号の2項演算子だと認識されてしまう．
      }．
      \TeX;の用語でいえば，ブロックテキストは垂直モードにおける記述，
      インラインテキストは水平モードにおける記述におおよそ対応する．
    }
    +p{
      ひとまず，上に掲げた例からPDFを生成してみよう．
      まずは適当なディレクトリに例示した文書ファイルを保存する．
      ファイル名は\path{hello.saty}とする．
      ターミナルを開き，\path{hello.saty}が置いてあるディレクトリに移動して

      \console(`$ satysfi hello.saty`);%

      を実行する．文書の記述に誤りがなければ，同じディレクトリに
      \path{hello.satysfi-aux}と\path{hello.pdf}が生成されるはずである．
      このうち\path{hello.satysfi-aux}は
      \dfnje{\index(`ホジョファイル`){補助ファイル}}{auxiliary file}
      あるいは\dfnje{\index(`ダンプファイル`){ダンプファイル}}{dump file}と呼ばれる副産物で，
      今は無視して構わない．\path{hello.pdf}が肝腎の生成物であり，
      これを開くとたしかにそれらしい小さな文書ができていることが確認できるだろう．
    }
    +p{
      さて，上に掲げた例には，
      \codem{+chapter\{ ${\cdots} \}\< ${\cdots} \>}やら\codem{+p\{ ${\cdots} \}}やら
      \codem{\\dfn\{ ${\cdots} \}}やら，
      なんとなくわかりそうだが妙に多くの記号が駆使された怪しげな記述がある\footnote{
        念のため書いておくと，\codem{+chapter}や\codem{+p}といったコマンドは
        \pkg{stdjareport}が規定しているもので，
        “\SATySFi;の言語機能に本質的に備わっているもの” ではない．
        その気になればクラスファイル\path{stdjareport.satyh}の中を覗いて
        実装を見ることができる．
      }．
      これらについて以下の節で見ていくこととしよう．
    }
  >
  +section{段落}<
    +p{
      段落は “文字の連なりを受け取ってページ方向に連なる行のリストにするもの” と捉え，
      インラインテキストを引数にとってブロックを返すコマンドで定式化されている．
      以下のように\codem{+p}コマンドでブロックテキスト内に記述する：

      \d-code-and-block(```
        +p{
          明日は明日の風が吹く
        }
      ```)<
        +p{
          明日は明日の風が吹く
        }
      >%

      上で「ブロック」と書いたものは正確には「ブロックテキスト」ではないが，
      ひとまずはブロックテキストとおおよそ同じものだと考えて差し支えない．
      ブロックテキスト内で使うコマンド，つまり “ブロックを返す” コマンドは
      名前が\codem{+}で始まり，
      \dfnje{\index(`ブロックコマンド`){ブロックコマンド}}{block command}と呼ぶ．
      一方インラインテキスト内で使うコマンドは名前が（\LaTeX;のコマンドと同様に）
      \codem{\\}で始まり，
      これを
      \dfnje{\index(`インラインコマンド`){インラインコマンド}}{inline command}
      と呼ぶ（後述）．
      いずれのコマンドの名前も，2文字目は大小ラテン文字，
      3文字目以降は大小ラテン文字，数字，ハイフンのいずれかである．
    }
    +p{
      コマンドに与える引数の構文は

      \listing{
        * \codem{( ${\cdots} )}： \dfnje{式引数}{expression argument}
        * \codem{\{ ${\cdots} \}}： \dfnje{インライン引数}{inline argument}
        * \codem{\< ${\cdots} \>}： \dfnje{ブロック引数}{block argument}
      }%

      の3種類に大別される\footnote{
        このうち式引数には\codem{( ${\cdots} )}の形ではない多少の変種があり，
        \codem{([ ${\cdots} ])}および\codem{((\| ${\cdots} \|))}という具合に
        直下が四角括弧であるものやレコード式であるものはそれぞれ単に
        \codem{[ ${\cdots} ]}および\codem{(\| ${\cdots} \|)}と書いて
        式引数として扱わせることができるのだが，
        今は気にしなくてよい．
      }．
      コマンドに引数を与えることをコマンドの\dfnje{適用}{application}と呼び，
      適用の構文は，正規表現風の擬似的なメタ記法を用いて

      \d-codem{
        \meta{cmd}\meta-star{( ${\cdots} )}%
          \meta-or{
            | \;
            | \meta-star{\meta-or{| \{ ${\cdots} \} | \< ${\cdots} \> |}}
            |}
      }%

      で表される．ここで\codem{\meta{cmd}}は，
      インラインテキスト中ではインラインコマンドを，
      ブロックテキスト中ではブロックコマンドをそれぞれ表す．
      要するに，コマンドの適用はまずコマンドの後ろに ${0} 個以上の式引数が並び，
      そしてその後ろに\codem{\;}か
      或いは各要素がインライン引数かブロック引数であるような長さ ${1} 以上の列かがきて終わる．
    }
    +p{
      ブロックテキスト，すなわち\codem{\< ${\cdots} \>}の中身は
      ブロックコマンドの適用の ${0} 個以上の列である．
      インラインテキスト，すなわち\codem{\{ ${\cdots} \}}の中には
      通常の文字列と
      インラインコマンドの適用とが書ける．
      ただし，いくつかの特殊な機能をもつ文字は，通常の文字列に含めるには
      \codem{\\}によるエスケープを要する．
      エスケープする必要のある文字は
      \codem{\{}，\codem{\}}，\codem{\<}，\codem{\>}，\codem{\|}，\codem{\%}，
      \codem{\*}，\codem{\;}，\codem{\#}，\codem{\$}，\codem{\\}，\codem{\@}，
      \codem{\`}
      である．
      このうち\codem{\;}だけは欧文でそれなりの頻度で出現するため，多少注意を要する．
    }
  >
  +section{章節}<
    +p{
      \codem{+chapter}，\codem{+section}，\codem{+subsection}を使う．
      名称は\LaTeX;に準じているが用法は少し異なり，ブロックテキスト内に以下のように記述する：

      \d-code(```
        +chapter{（章題）}<
          （内容）
        >
      ```);%

      章題だけではなく，その章の内容をブロックテキストとして第2引数に与えるという形で定式化されている．
      章題は文字の連なりなのでインラインテキスト，内容は段落のページ方向への積み重なりなのでブロックテキストである．
      \codem{+section}，\codem{+subsection}の用法も全く同様．
    }
  >
  +section{新出単語}<
    +p{
      新たに定義される名称や言い回しは，インラインコマンド\codem{\\dfn}で囲む．
      インラインテキスト中で以下のように使う：

      \d-code-and-block(```
        +p{
          原稿とデザインにしたがって活字や図版を配置して
          版面を構成することを総称して\dfn{組版処理}と呼ぶ．
        }
      ```)<
        +p{
          原稿とデザインにしたがって活字や図版を配置して
          版面を構成することを総称して\dfn{組版処理}と呼ぶ．
        }
      >%

      引数として囲まれた部分のラテン文字がイタリック体になる．
      このように，インラインコマンドとは
      “（何らかの加工が施された）文字の連なり” を返すコマンドなのである．
      なお，既に述べたコマンドの適用の構文からわかるように，
      引数のないインラインコマンドはセミコロンをつける：

      \d-code-and-block(```
        +p{ \SATySFi; is a new typesetting system. }
      ```)<
        +p{ \SATySFi; is a new typesetting system. }
      >%
    }
  >
  +section{文中数式}<
    +p{
      文中数式は，インラインテキスト中に\codem{\$\{ ${\cdots} \}}で囲って書く．
      記法はかなり\LaTeX;に近く，以下のような例だと
      \codem{\$\{ ${\cdots} \}}の中身は見かけ上\LaTeX;コードと完全に一致する：

      \d-code-and-block(```
        +p{
          数式は\LaTeX;と同様に
          ${E = m c^2}，${F = G \frac{m_1 m_2}{r^2}}，
          ${x^x = e^{x \log x}}
          といった要領で書くことができます．
        }
      ```)<
        +p{
          数式は\LaTeX;と同様に
          ${E = m c^2}，${F = G \frac{m_1 m_2}{r^2}}，
          ${x^x = e^{x \log x}}
          といった要領で書くことができます．
        }
      >%

      数式中のコマンドである\dfnje{数式コマンド}{math command}は
      インラインコマンドと同様に\codem{\\}から名前が始まる．
      同一の名前をインラインコマンドと数式コマンドの両方で
      使うことはできない（つまり，名前空間は分かれていない）．
      インラインコマンドの場合とは違い，引数のない数式コマンドの使用に\codem{\;}はつけない．
    }
    +p{
      \LaTeX;の数式の記法とよく似ているもののいくつかの違いがあり，
      特に括弧類の扱いは顕著に\LaTeX;とは異なる．
      \LaTeX;の
      \code(`\left`);・\code(`\right`);・\code(`\middle`);
      に相当するものはなく，
      代わりに括弧が左右合わせてひとつのコマンドとして定義されている．
      丸括弧で囲いたい場合は\codem{\\paren\{（囲う式）\}}と記述する．
      丸括弧のほか，集合の外延記法は\codem{\\set\{ ${\cdots} \}}，
      内包記法は\codem{\\setsep\{ ${\cdots} \}\{ ${\cdots} \}}，
      絶対値は\codem{\\abs\{ ${\cdots} \}}，
      距離やノルムに使う2本線の括弧は\codem{\\dist\{ ${\cdots} \}}という数式コマンドにより提供されている．
      また，函数の適用は\codem{\\app\{f\}\{x\}}という具合に書けるようになっている．
    }
    +p{
      なお，四角括弧，（集合に限らない一般の）波括弧，三角括弧もそれぞれ
      \codem{\\sqbracket\{ ${\cdots} \}}，\codem{\\brace\{ ${\cdots} \}}，
      \codem{\\angle-bracket\{ ${\cdots} \}}
      で書けるようになっているが，これらのコマンドは数式の “意味” を指しているわけではないので，
      一応直接数式に書くというよりはユーザ定義コマンド（後述）の定義中で使うことを
      主たる用法として想定している\footnote{
        と言いつつ，次節の例で\codem{\\sqbracket}を数式中に直接書いているが．
      }．
    }
    +p{
      その他，数式について詳しくは\ref-chapter(`math`);で扱う．
    }
  >
  +section{別行立て数式}<
    +p{
      \d-code-and-block(```
        +p{
          別行立て数式は，少し前後がゴチャッとしているが
          \eqn(${
            \int_a^b \frac{\ordd x}{\sqrt{x^2 + 1}}
              = \sqbracket{\log \paren{x + \sqrt{x^2 + 1}}}_a^b
          });%
          という具合に書く．位置を揃えたい場合は，さらにゴチャッとするが
          \align[
            ${| \paren{x - a} \paren{x - b}
                  |= x^2 - a x - b x + a b |};
            ${|   |= x^2 - \paren{a + b} x + a b |};
          ];%
          という要領で書く．
        }
      ```)(open Sample in '<
        +p{
          別行立て数式は，少し前後がゴチャッとしているが

          \eqn(${
            \int_a^b \frac{\ordd x}{\sqrt{x^2 + 1}}
              = \sqbracket{\log \paren{x + \sqrt{x^2 + 1}}}_a^b
          });%

          という具合に書く．位置を揃えたい場合は，さらにゴチャッとするが

          \align[
            ${| \paren{x - a} \paren{x - b}
                  |= x^2 - a x - b x + a b |};
            ${|   |= x^2 - \paren{a + b} x + a b |};
          ];%

          という要領で書く．
        }
      >);%

      \codem{\\align}の引数の\codem{[ ${\cdots} ]}は
      直下に四角括弧があるプログラム引数\codem{([ ${\cdots} ])}の略記であり，
      プログラムに於ける\codem{[ ${\cdots} ]}は
      \dfnje{リスト}{list}である\footnote{
        リストといっても，箇条書きの意味のリストとは特に関係がないことに注意．
        これについては\ref-chapter(`basic-command-definition`);で説明する．
      }．
    }
  >
  +section{コメントアウト}<
    +p{
      単行コメントアウトは\LaTeX;と全く同様に\codem{\%}によって行なう．
      単純にコメントアウトとして使うだけでなく，
      インラインテキスト中で改行文字を入力として与えずにソース上で改行するのに使うことができる．
      複数行のコメントアウトは現在は備わっていないが，
      明らかにあると便利なので近い将来追加するつもりでいる．
    }
  >
  +section{箇条書き}<
    +p{
      箇条書きは\pkg{itemize}パッケージを読み込むと使える．
      ブロックテキスト中で

      \d-code(```
        +listing{
          * 東京
            ** 本郷
            ** 弥生
            ** 浅野
            ** 駒場
          * 千葉
            ** 柏
        }
      ```);%

      と書くほか，インラインテキスト中でも

      \d-code(```
        \listing{
          * 東京
            （中略）
            ** 柏
        }%
      ```);%

      という具合に書ける．箇条書きは “ページ方向に積み重なるもの” なので基本的には “ブロック” なのだが，
      マークアップの都合上段落中などでも使えるようにインラインコマンド版も提供されている．
      ただし，インラインコマンド版は末尾にコメントアウトの文字
      \codem{\%}をつける必要がある\footnote{
        これがないと，\codem{\}}直後の改行文字に由来して
        次の文字の前に余分なスペースが挿入されてしまう．
        やや微妙な性質なので
        今後\codem{\%}を書かなくてよいように改善したいと検討している．
      }．
      見てのとおり多重構造も扱え，階層は\codem{\*}の連続する個数によって判定される
      （インデントは単に見やすさのためにつけてあるだけである）．
      既に述べたように，\codem{\*}はこの機能のために特殊な文字として扱われている都合上
      通常のテキストとして書くには\codem{\\\*}とエスケープする必要がある．
    }
    +p{
      ちなみに，上に掲げた例の箇条書きの部分\codem{\{ ${\cdots} \}}はインラインテキストではなく，
      itemize 型という箇条書き専用の型がつくテキストになっており，
      通常のインラインテキストを与えると型エラーとなる．
      これについては\ref-chapter(`basic-command-definition`);で後述する．
    }
  >
  +section{定理環境}<
    +p{
      \pkg{stdjareport}には定義・補題・定理・系・例のための環境一式が備わっており，
      コマンドはそれぞれ
      \codem{+definition}，\codem{+lemma}，\codem{+theorem}，
      \codem{+corollary}，\codem{+example}
      である．いずれも用法は同様で，最も簡素な使い方としてはブロックテキスト中で
      \d-code(```
        +theorem{
          （内容）
        }
      ```);
      などと書く．環境中で改段落することは想定されていないので，内容はインラインテキストで与える．
      オプション引数としてタイトルを与えることができる：

      \d-code-and-block(```
        +theorem?:({進行}){
          ${t} が型のつく項ならば，以下のいずれかが成り立つ：
          \listing{
            * ${t} は値．
            * 或る ${t'} が存在して ${t \to t'} を満たす．
          }%
        }
      ```)<
        +theorem?:({進行}){
          ${t} が型のつく項ならば，以下のいずれかが成り立つ：
          \listing{
            * ${t} は値．
            * 或る ${t'} が存在して ${t \to t'} を満たす．
          }%
        }
      >%

      \codem{?:( ${\cdots} )}がオプション引数を与える構文である．
    }
  >
  +section{脚註}<
    +p{
      脚註の用法はほぼ\LaTeX;と同様で，インラインテキスト中に
      \codem{\\footnote\{ ${\cdots} \}}
      と記述することで挿入できる．
      ただし，脚註の中にさらに脚註の記述を設けることなどはできない．
    }
  >
  +section{相互参照}<
    +p{
      相互参照は\ref-chapter(`introduction`);でも述べたとおり
      マークアップ方式の組版処理システムが簡潔に実現することを得意としやすい機能だ．
      \SATySFi;も相互参照機能を備えており，
      \pkg{stdjareport}はそれを利用して相互参照のインターフェイスを実現している．
      実は，既に紹介した章節や定理環境のコマンドたちは，オプション引数として相互参照のラベルを受け取ることができる\footnote{
        勿論，相互参照のラベルを渡しても章節そのものの組版結果は特に変わらない．
      }：

      \d-code(```
        +chapter?:(`introduction`){はじめに}<
          （中略）
        >
      ```);%

      そして，章番号を使いたい箇所で\codem{\\ref-chapter}を用いて挿入する：

      \d-code-and-block(```
        +p{
          相互参照は\ref-chapter(`introduction`);でも述べたとおり
          マークアップ方式の組版処理システムが
          簡潔に実現することを得意としやすい機能だ．
          （以下略）
        }
      ```)<
        +p{
          相互参照は\ref-chapter(`introduction`);でも述べたとおり
          マークアップ方式の組版処理システムが
          簡潔に実現することを得意としやすい機能だ．
          （以下略）
        }
      >%

      定理類のコマンドも，2番目のオプション引数として相互参照のラベルが挿入できる：

      \d-code-and-block(```
        +lemma?:({保存})?:(`preservation`){
          ${\Gamma \vdash t : \tau} かつ ${t \to t'} ならば，
          ${\Gamma \vdash t' : \tau} が成り立つ．
        }
      ```)<
        +lemma?:({保存})?:(`preservation`){
          ${\Gamma \vdash t : \tau} かつ ${t \to t'} ならば，
          ${\Gamma \vdash t' : \tau} が成り立つ．
        }
      >%

      連続するオプション引数でより手前側のものを省略し後ろ側のものを与えたい場合は，
      オプション引数の “省略の明示” である\codem{?\*}を使う．
      ここでは補題のタイトルが不要だが相互参照のラベルをつけたい場合は
      以下のように改めればよい：

      \d-code-and-block(```
        +lemma?*?:(`preservation-without-title`){
          ${\Gamma \vdash t : \tau} かつ ${t \to t'} ならば，
          ${\Gamma \vdash t' : \tau} が成り立つ．
        }
      ```)<
        +lemma?*?:(`preservation-without-title`){
          ${\Gamma \vdash t : \tau} かつ ${t \to t'} ならば，
          ${\Gamma \vdash t' : \tau} が成り立つ．
        }
      >%

      そして実際に番号を挿入する場所では
      \codem{\\ref-theorem}，\codem{\\ref-lemma}，…などを使う：

      \d-code-and-block(```
        +proof{
          \ref-lemma(`preservation`);よりすみやかにしたがう．
        }
      ```)<
        +proof{
          \ref-lemma(`preservation`);よりすみやかにしたがう．
        }
      >%
    }
  >
>
